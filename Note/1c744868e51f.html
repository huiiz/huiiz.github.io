<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>操作系统 from 蒋炎岩nju2023 | HUII's Blog</title><meta name="author" content="HUII"><meta name="copyright" content="HUII"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="注意：本页面停止更新，后续内容更新在我的notion笔记：操作系统 (notion.site)  2023年6月29日，by:HUII 概述 本课程来源于南京大学计算机软件研究所的jyy老师。绿导师原谅你了的个人空间_哔哩哔哩_bilibili 课程资料官网：操作系统：设计与实现 (2023 春季学期) (jyywiki.cn) 操作系统课程 去年（2022）就尝试看完jyy老师的课程，但最终没能">
<meta property="og:type" content="article">
<meta property="og:title" content="操作系统 from 蒋炎岩nju2023">
<meta property="og:url" content="https://blog.huii.top/Note/1c744868e51f.html">
<meta property="og:site_name" content="HUII&#39;s Blog">
<meta property="og:description" content="注意：本页面停止更新，后续内容更新在我的notion笔记：操作系统 (notion.site)  2023年6月29日，by:HUII 概述 本课程来源于南京大学计算机软件研究所的jyy老师。绿导师原谅你了的个人空间_哔哩哔哩_bilibili 课程资料官网：操作系统：设计与实现 (2023 春季学期) (jyywiki.cn) 操作系统课程 去年（2022）就尝试看完jyy老师的课程，但最终没能">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://blog.huii.top/img/image-8.png">
<meta property="article:published_time" content="2023-02-14T13:58:00.000Z">
<meta property="article:modified_time" content="2023-10-06T02:24:16.516Z">
<meta property="article:author" content="HUII">
<meta property="article:tag" content="操作系统">
<meta property="article:tag" content="OS">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://blog.huii.top/img/image-8.png"><link rel="shortcut icon" href="/img/logo.png"><link rel="canonical" href="https://blog.huii.top/Note/1c744868e51f.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: {"limitDay":128,"position":"top","messagePrev":"本文最后更新于","messageNext":"天前，其中的信息可能已经有所发展或是发生改变。"},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: HUII","link":"链接: ","source":"来源: HUII's Blog","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '操作系统 from 蒋炎岩nju2023',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-10-06 10:24:16'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">36</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">41</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文章归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签云</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/image-8.png')"><nav id="nav"><span id="blog-info"><a href="/" title="HUII's Blog"><img class="site-icon" src="/img/logo.png"/><span class="site-name">HUII's Blog</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文章归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签云</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">操作系统 from 蒋炎岩nju2023</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-02-14T13:58:00.000Z" title="发表于 2023-02-14 21:58:00">2023-02-14</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-10-06T02:24:16.516Z" title="更新于 2023-10-06 10:24:16">2023-10-06</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Note/">Note</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="操作系统 from 蒋炎岩nju2023"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>注意：本页面停止更新，后续内容更新在我的notion笔记：<a target="_blank" rel="noopener" href="https://zhuii.notion.site/zhuii/9e6aec0d43eb417eb695779716d8bda6">操作系统 (notion.site)</a> </p>
<p>2023年6月29日，by:HUII</p>
<p><strong>概述</strong></p>
<p>本课程来源于南京大学<a target="_blank" rel="noopener" href="http://ics.nju.edu.cn/">计算机软件研究所</a>的jyy老师。<a target="_blank" rel="noopener" href="https://space.bilibili.com/202224425">绿导师原谅你了的个人空间_哔哩哔哩_bilibili</a></p>
<p>课程资料官网：<a target="_blank" rel="noopener" href="https://jyywiki.cn/OS/2023/">操作系统：设计与实现 (2023 春季学期) (jyywiki.cn)</a></p>
<p><img src="../img/image-8.png" alt="img">操作系统课程</p>
<p>去年（2022）就尝试看完jyy老师的课程，但最终没能成功😅，希望今年能够尽量跟上jyy老师的进度。</p>
<hr>
<p>失败了</p>
<h1 id="绪论1-操作系统概述-2023-2-14"><a href="#绪论1-操作系统概述-2023-2-14" class="headerlink" title="绪论1_操作系统概述_2023.2.14"></a>绪论1_操作系统概述_2023.2.14</h1><iframe src="https://jyywiki.cn/OS/2023/build/lect1.ipynb.html" width="100%" height="600"></iframe>

<h2 id="Why为什么学操作系统"><a href="#Why为什么学操作系统" class="headerlink" title="Why为什么学操作系统"></a>Why为什么学操作系统</h2><ul>
<li>觉醒体内“编程能力”</li>
<li>补完编程技能体系</li>
</ul>
<h2 id="What什么是操作系统"><a href="#What什么是操作系统" class="headerlink" title="What什么是操作系统"></a>What什么是操作系统</h2><blockquote>
<p>Operating System: A body of software, in fact, that is responsible for <em>making it easy to run programs</em> (even allowing you to seemingly run many at the same time), allowing programs to share memory, enabling programs to interact with devices, and other fun stuff like that. (OSTEP)</p>
</blockquote>
<p>让程序可以与其它程序以及硬件交互</p>
<p><img src="../img/image-10-16965174394544.png" alt="img">什么是操作系统</p>
<p>操作系统：硬件和软件的中间层</p>
<p><img src="../img/image-11-1024x491.png" alt="img">Fortran卡片</p>
<p>历史：</p>
<ul>
<li><p>ENIAC: 1946.2.14</p>
</li>
<li><p>1940s</p>
<ul>
<li>硬件<ul>
<li>逻辑门：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/av59005720">真空电子管</a></li>
<li>存储器：延迟线 (delay lines)</li>
<li>输入/输出：打孔纸带/指示灯</li>
</ul>
</li>
<li><p>软件：打印平方数、素数表、计算弹道……</p>
</li>
<li><p>操作系统：没有</p>
<ul>
<li>程序直接用指令操作硬件</li>
<li>不需要画蛇添足的程序来管理它</li>
</ul>
</li>
</ul>
</li>
<li><p>1950s</p>
<ul>
<li>硬件：更快更小的逻辑门 (晶体管)、更大的内存 (磁芯)、丰富的 I/O 设备<ul>
<li>I/O 设备的速度已经严重低于处理器的速度，中断机制出现 (1953)</li>
</ul>
</li>
<li>软件：更复杂的通用的数值计算。自然科学、工程机械、军事……对计算机的需求暴涨<ul>
<li>高级语言和 API 诞生 (Fortran, 1957)：一行代码，一张卡片</li>
<li>80 行的规范沿用至今 (细节：打印机会印刷本行代码)</li>
</ul>
</li>
<li>操作系统：库函数 + 管理程序排队运行的调度代码。<ul>
<li>写程序 (戳纸带)、跑程序都是非常费事的<ul>
<li>计算机非常贵 ($50,000−$1,000,000$50,000−$1,000,000)，一个学校只有一台</li>
<li>算力成为一种服务：多用户轮流共享计算机，operator 负责调度</li>
</ul>
</li>
<li>操作 (operate) 任务 (jobs) 的系统 (system)<ul>
<li>“批处理系统” = 程序的自动切换 (换卡) + 库函数 API</li>
<li>Disk Operating Systems (DOS)<ul>
<li>操作系统中开始出现 “设备”、“文件”、“任务” 等对象和 API</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>1960s</p>
<ul>
<li>硬件：集成电路、总线出现<ul>
<li>更快的处理器</li>
<li>更快、更大的内存；虚拟存储出现<ul>
<li>可以同时载入多个程序而不用 “换卡” 了</li>
</ul>
</li>
<li>更丰富的 I/O 设备；完善的中断/异常机制</li>
</ul>
</li>
<li>软件：更多的高级语言和编译器出现<ul>
<li>COBOL (1960), APL (1962), BASIC (1965)<ul>
<li>Bill Gates 和 Paul Allen 在 1975 年实现了 Altair 8800 上的 BASIC 解释器</li>
</ul>
</li>
</ul>
</li>
<li>操作系统：能载入多个程序到内存且调度它们的管理程序。<ul>
<li>为防止程序之间形成干扰，操作系统自然地将共享资源 (如设备) 以 API 形式管理起来<ul>
<li>有了进程 (process) 的概念</li>
<li>进程在执行 I/O 时，可以将 CPU 让给另一个进程<ul>
<li>在多个地址空间隔离的程序之间切换</li>
<li>虚拟存储使一个程序出 bug 不会 crash 整个系统</li>
</ul>
</li>
</ul>
</li>
<li>操作系统中自然地增加进程管理 API<ul>
<li>既然可以在程序之间切换，为什么不让它们定时切换呢？</li>
<li>Multics (MIT, 1965)：现代分时操作系统诞生</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>1970s+</p>
<ul>
<li>硬件：集成电路空前发展，个人电脑兴起，“计算机” 已与今日无大异<ul>
<li>CISC 指令集；中断、I/O、异常、MMU、网络</li>
<li>个人计算机 (PC 机)、超级计算机……</li>
</ul>
</li>
<li>软件<ul>
<li>PASCAL (1970), C (1972), …</li>
<li>今天能办到的，那个时代已经都能办到了——上天入地、图像声音视频、人工智能……</li>
<li>个人开发者 (Geek Network) 走上舞台</li>
</ul>
</li>
<li>操作系统：分时系统走向成熟，UNIX 诞生并走向完善，奠定了现代操作系统的形态。<ul>
<li>1973: 信号 API、管道 (对象)、grep (应用程序)</li>
<li>1983: BSD socket (对象)</li>
<li>1984: procfs (对象)……</li>
<li>UNIX 衍生出的大家族<ul>
<li>1BSD (1977), GNU (1983), MacOS (1984), AIX (1986), Minix (1987), Windows (1985), Linux 0.01 (1991), Windows NT (1993), Debian (1996), Windows XP (2002), Ubuntu (2004), iOS (2007), Android (2008), Windows 10 (2015), ……</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>今天的操作系统</p>
<ul>
<li>通过 “虚拟化” 硬件资源为程序运行提供服务的软件。</li>
</ul>
</li>
</ul>
<h2 id="How怎样学操作系统"><a href="#How怎样学操作系统" class="headerlink" title="How怎样学操作系统"></a>How怎样学操作系统</h2><h2 id="课程代码"><a href="#课程代码" class="headerlink" title="课程代码"></a>课程代码</h2><h3 id="模拟数字系统"><a href="#模拟数字系统" class="headerlink" title="模拟数字系统"></a>模拟数字系统</h3><ul>
<li>seven-seg.py</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">import fileinput</span><br><span class="line"> </span><br><span class="line">DISPLAY = &#x27;&#x27;&#x27;</span><br><span class="line">     AAAAAAAAA</span><br><span class="line">    FF       BB</span><br><span class="line">    FF       BB</span><br><span class="line">    FF       BB</span><br><span class="line">    FF       BB</span><br><span class="line">     GGGGGGGG</span><br><span class="line">   EE       CC</span><br><span class="line">   EE       CC</span><br><span class="line">   EE       CC</span><br><span class="line">   EE       CC</span><br><span class="line">    DDDDDDDDD</span><br><span class="line">&#x27;&#x27;&#x27; </span><br><span class="line"></span><br><span class="line"># STFW: ANSI Escape Code</span><br><span class="line">CLEAR = &#x27;\033[2J\033[1;1f&#x27;</span><br><span class="line">BLOCK = &#123;</span><br><span class="line">    0: &#x27;\033[37m░\033[0m&#x27;,</span><br><span class="line">    1: &#x27;\033[31m█\033[0m&#x27;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for line in fileinput.input():</span><br><span class="line">    # Load &quot;A=0; B=1; ...&quot; to current context</span><br><span class="line">    exec(line)</span><br><span class="line"></span><br><span class="line">    # Render the seven-segment display</span><br><span class="line">    pic = DISPLAY</span><br><span class="line">    for seg in set(DISPLAY):</span><br><span class="line">        if seg.isalpha():</span><br><span class="line">            val = globals()[seg]  # 0 or 1</span><br><span class="line">            pic = pic.replace(seg, BLOCK[val])</span><br><span class="line"></span><br><span class="line">    # Clear screen and display</span><br><span class="line">    print(CLEAR + pic)</span><br></pre></td></tr></table></figure>
<ul>
<li>logisim.c</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdbool.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">typedef bool wire; // Wires</span><br><span class="line">typedef struct &#123;</span><br><span class="line">  bool value;</span><br><span class="line">  wire *in, *out;</span><br><span class="line">&#125; reg; // Flip-flops</span><br><span class="line"></span><br><span class="line">// Circuit constructs</span><br><span class="line">#define CLOCK       for (; ; END_CYCLE)</span><br><span class="line">#define NAND(X, Y)  (!((X) &amp;&amp; (Y)))</span><br><span class="line">#define NOT(X)      (NAND(X, 1))</span><br><span class="line">#define AND(X, Y)   (NOT(NAND(X, Y)))</span><br><span class="line">#define OR(X, Y)    (NAND(NOT(X), NOT(Y)))</span><br><span class="line"></span><br><span class="line">// Circuit emulation helpers</span><br><span class="line">#define END_CYCLE (&#123; end_cycle(); putchar(&#x27;\n&#x27;); fflush(stdout); sleep(1); &#125;)</span><br><span class="line">#define PRINT(X) printf(#X &quot; = %d; &quot;, X)</span><br><span class="line"></span><br><span class="line">// Wire and register specification</span><br><span class="line">wire X, Y, X1, Y1, A, B, C, D, E, F, G;</span><br><span class="line">reg b1 = &#123;.in = &amp;X1, .out = &amp;X&#125;;</span><br><span class="line">reg b0 = &#123;.in = &amp;Y1, .out = &amp;Y&#125;;</span><br><span class="line"></span><br><span class="line">// Dump wire values at the end of each cycle</span><br><span class="line">void end_cycle() &#123;</span><br><span class="line">  PRINT(A); PRINT(B); PRINT(C); PRINT(D);</span><br><span class="line">  PRINT(E); PRINT(F); PRINT(G);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">  CLOCK &#123;</span><br><span class="line">    // 1. Wire network specification (logic gates)</span><br><span class="line">    X1 = AND(NOT(X), Y);</span><br><span class="line">    Y1 = NOT(OR(X, Y));</span><br><span class="line">    A = D = E = NOT(Y);</span><br><span class="line">    B = 1;</span><br><span class="line">    C = NOT(X);</span><br><span class="line">    F = Y1;</span><br><span class="line">    G = X;</span><br><span class="line"></span><br><span class="line">    // 2. Lock data in flip-flops and propagate output to wires</span><br><span class="line">    b0.value = *b0.in;</span><br><span class="line">    b1.value = *b1.in;</span><br><span class="line">    *b0.out = b0.value;</span><br><span class="line">    *b1.out = b1.value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Makefile</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">a.out: logisim.c</span><br><span class="line">	gcc $(CFLAGS) logisim.c</span><br><span class="line"></span><br><span class="line">run: a.out</span><br><span class="line">	./a.out | python3 seven-seg.py  # The UNIX Philosophy</span><br><span class="line"></span><br><span class="line">clean:</span><br><span class="line">	rm -f a.out</span><br></pre></td></tr></table></figure>
<ul>
<li>编译</li>
</ul>
<p>在当前目录下执行<code>make</code></p>
<ul>
<li>运行</li>
</ul>
<p>在当前目录下执行<code>make run</code>或.<code>/a.out | python3 seven-seg.py</code>。</p>
<p><img src="../img/image-12-16965174394557.png" alt="img">模拟数字系统运行结果</p>
<h3 id="模拟-RISC-V-指令执行"><a href="#模拟-RISC-V-指令执行" class="headerlink" title="模拟 RISC-V 指令执行"></a>模拟 RISC-V 指令执行</h3><p>这里解决了一个鸡兔同笼问题</p>
<ul>
<li>jitu.txt</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">00050713</span><br><span class="line">00151793</span><br><span class="line">40f587b3</span><br><span class="line">0017d793</span><br><span class="line">00200513</span><br><span class="line">40f705b3</span><br><span class="line">00100073</span><br><span class="line">00100513</span><br><span class="line">02000593</span><br><span class="line">00100073</span><br><span class="line">00200513</span><br><span class="line">00078593</span><br><span class="line">00100073</span><br><span class="line">00100513</span><br><span class="line">00a00593</span><br><span class="line">00100073</span><br><span class="line">00300513</span><br><span class="line">00100073</span><br><span class="line">0000006f</span><br></pre></td></tr></table></figure>
<ul>
<li>uncore.c</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">static inline bool inst_fetch(inst_t *in) &#123;</span><br><span class="line">  union &#123;</span><br><span class="line">    inst_t i;</span><br><span class="line">    u32 u;</span><br><span class="line">  &#125; u;</span><br><span class="line">  int r = scanf(&quot;%x&quot;, &amp;u.u);</span><br><span class="line">  *in = u.i;</span><br><span class="line">  return r &gt; 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static inline void ebreak(CPUState *cpu) &#123;</span><br><span class="line">  switch (cpu-&gt;x[10]) &#123;</span><br><span class="line">    case 1: &#123; putchar(cpu-&gt;x[11]); break; &#125;</span><br><span class="line">    case 2: &#123; printf(&quot;%d&quot;, cpu-&gt;x[11]); break; &#125;</span><br><span class="line">    case 3: &#123; cpu-&gt;on = false; break; &#125;</span><br><span class="line">    default: assert(0);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>rvemu.c</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdint.h&gt;</span><br><span class="line">#include &lt;assert.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;stdbool.h&gt;</span><br><span class="line">typedef uint32_t u32;</span><br><span class="line"></span><br><span class="line">typedef struct &#123; u32 op:7, rd:5, f3:3, rs1:5, rs2:5, f7:7; &#125; inst_t;</span><br><span class="line">typedef struct &#123;</span><br><span class="line">  u32 on, x[32];</span><br><span class="line">&#125; CPUState;</span><br><span class="line"></span><br><span class="line">// Uncore:</span><br><span class="line">//   inst_fetch - read an instruction from stdin</span><br><span class="line">//   ebreak - hyper call: putchar/putd/exit</span><br><span class="line">#include &quot;uncore.c&quot;</span><br><span class="line"></span><br><span class="line">static inline u32 sext(u32 val, u32 n) &#123;</span><br><span class="line">  // Sign extend n-bit integer val to 32-bit</span><br><span class="line">  u32 mask = ~((1 &lt;&lt; n) - 1);</span><br><span class="line">  u32 set = (val &gt;&gt; n) &amp; 1;</span><br><span class="line">  u32 ret = set ? (val | mask) : val;</span><br><span class="line">  return ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[]) &#123;</span><br><span class="line">  CPUState cpu = &#123;.on = 1, .x = &#123; 0 &#125;&#125;; // The RESET state</span><br><span class="line">  for (int i = 0; argv[i + 1] &amp;&amp; i &lt; 8; i++) &#123;</span><br><span class="line">    cpu.x[10 + i] = atoi(argv[i + 1]); // Set a0-a7 to arguments</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  inst_t in;</span><br><span class="line">  while (cpu.on &amp;&amp; inst_fetch(&amp;in)) &#123;</span><br><span class="line">    // For each fetched instruction, execute it following the RV32I spec</span><br><span class="line">    u32 op = in.op, f3 = in.f3, f7 = in.f7;</span><br><span class="line">    u32 imm = sext((f7 &lt;&lt; 5) | in.rs2, 12), shamt = in.rs2;</span><br><span class="line">    u32 rd = in.rd, rs1_u = cpu.x[in.rs1], rs2_u = cpu.x[in.rs2], res = 0;</span><br><span class="line"></span><br><span class="line">    #define __ else if // Bad syntactic sugar!</span><br><span class="line">    if (op == 0b0110011 &amp;&amp; f3 == 0b000 &amp;&amp; f7 == 0b0000000) res = rs1_u + rs2_u;</span><br><span class="line">    __ (op == 0b0110011 &amp;&amp; f3 == 0b000 &amp;&amp; f7 == 0b0100000) res = rs1_u - rs2_u;</span><br><span class="line">    __ (op == 0b0010011 &amp;&amp; f3 == 0b000)                    res = rs1_u + imm;</span><br><span class="line">    __ (op == 0b0010011 &amp;&amp; f3 == 0b001 &amp;&amp; f7 == 0b0000000) res = rs1_u &lt;&lt; shamt;</span><br><span class="line">    __ (op == 0b0010011 &amp;&amp; f3 == 0b101 &amp;&amp; f7 == 0b0000000) res = rs1_u &gt;&gt; shamt;</span><br><span class="line">    __ (op == 0b1110011 &amp;&amp; f3 == 0b000 &amp;&amp; rd == 0 &amp;&amp; imm == 1) ebreak(&amp;cpu);</span><br><span class="line">    else assert(0);</span><br><span class="line">    if (rd) cpu.x[rd] = res;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Makefile</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">a.out: rvemu.c uncore.c</span><br><span class="line"># RTFM: Automatic variables</span><br><span class="line">	gcc $(CFLAGS) $&lt;</span><br><span class="line"></span><br><span class="line">run: a.out</span><br><span class="line">	@echo 2 Head, 4 Feet:</span><br><span class="line">	@cat ji-tu.txt | ./a.out 2 4</span><br><span class="line">	@echo 2 Head, 6 Feet:</span><br><span class="line">	@cat ji-tu.txt | ./a.out 2 6</span><br><span class="line">	@echo 2 Head, 8 Feet:</span><br><span class="line">	@cat ji-tu.txt | ./a.out 2 8</span><br><span class="line">	@echo 35 Head, 94 Feet:</span><br><span class="line">	@cat ji-tu.txt | ./a.out 35 94</span><br><span class="line"></span><br><span class="line">clean:</span><br><span class="line">	rm -f a.out</span><br></pre></td></tr></table></figure>
<ul>
<li>编译</li>
</ul>
<p>在当前目录下执行<code>make</code></p>
<ul>
<li>运行</li>
</ul>
<p>在当前目录下执行<code>make run</code>。</p>
<p><img src="../img/image-13-16965174394559.png" alt="img">模拟 RISC-V 指令执行</p>
<h1 id="绪论2-应用视角的操作系统-2023-2-16"><a href="#绪论2-应用视角的操作系统-2023-2-16" class="headerlink" title="绪论2_应用视角的操作系统_2023.2.16"></a>绪论2_应用视角的操作系统_2023.2.16</h1><h2 id="汇编代码和最小可执行文件"><a href="#汇编代码和最小可执行文件" class="headerlink" title="汇编代码和最小可执行文件"></a>汇编代码和最小可执行文件</h2><h3 id="构造最小的-Hello-World-“应用程序”"><a href="#构造最小的-Hello-World-“应用程序”" class="headerlink" title="构造最小的 Hello, World “应用程序”"></a>构造最小的 Hello, World “应用程序”</h3><p>编译完成后文件大小为16KB。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">  printf(&quot;Hello World\n&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用objdump工具查看汇编代码<code>objdump -d a.out | less</code>。</p>
<p>使用静态文件进行编译，<code>gcc hello.c -static</code>，编译完成后大小为880kb，查看行数，<code>objdump -d a.out | wc -l</code>，共154193行。</p>
<p>打开gcc的日志功能<code>gcc hello.c -static --verbose</code>，可以打印出编译时的运行日志。</p>
<p><img src="../img/image-14-169651743945511.png" alt="img">gcc运行日志</p>
<p>编译过程：.c(源代码)-&gt;.i(预编译源代码)-gcc-&gt;.S(汇编代码)-as-&gt;.o-ld-&gt;a.out</p>
<p>打印链接选项<code>gcc hello.c -static -Wl,--verbose</code>。可以看到它链接了很多东西。</p>
<h3 id="强行构造最小的-Hello-World？"><a href="#强行构造最小的-Hello-World？" class="headerlink" title="强行构造最小的 Hello, World？"></a>强行构造最小的 Hello, World？</h3><p>使用<code>gcc -E hello.c</code>可以看到预编译结果。</p>
<p><img src="../img/image-15-169651743945513.png" alt="img">预编译结果（部分）</p>
<p>使用<code>gcc -c hello.c</code>生成hello.o,使用<code>objdump -d hello.o</code>查看内容。</p>
<p><img src="../img/image-19-169651743945515.png" alt="img">查看内容</p>
<p>使用ld命令强行链接，<code>ld hello.o</code>，会出现一个warning和一个error。</p>
<p><img src="../img/image-16.png" alt="img">强行链接结果</p>
<p>去除外部依赖，重新编译。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="../img/image-17.png" alt="img">查看内容</p>
<p>链接后只存在一个warning，可以使用<code>ld hello.o -e main</code>强行消除警告。</p>
<p><img src="../img/image-20-169651743945519.png" alt="img">链接警告</p>
<p>使用objdump查看。</p>
<p><img src="../img/image-21-169651743945521.png" alt="img">最小a.out</p>
<p>不过运行存在错误。</p>
<p><img src="../img/image-22-169651743945523.png" alt="img">运行提示Segmentation fault</p>
<p>将代码改为死循环，程序可正常运行。</p>
<p><img src="../img/image-23.png" alt="img">改为死循环</p>
<h4 id="为什么会-Segmentation-Fault？"><a href="#为什么会-Segmentation-Fault？" class="headerlink" title="为什么会 Segmentation Fault？"></a>为什么会 Segmentation Fault？</h4><p>使用调试器gbd工具进行调试，<code>gdb a.out</code>。</p>
<p><img src="../img/image-24.png" alt="img">启动gdb</p>
<p>（在gdb中）执行<code>starti</code>程序将从指令第一条开始执行。使用<code>layout asm</code>可以将汇编显示在界面上方（text ui）。</p>
<p><img src="../img/image-25.png" alt="img">text ui</p>
<p>使用info registers查看寄存器状态。</p>
<p><img src="../img/image-26.png" alt="img">寄存器状态</p>
<p>通过 调试可以看到，是在返回时出现错误，最后指到了0x00000001地址。</p>
<p><img src="../img/image-27.png" alt="img">返回时的出错</p>
<h3 id="解决异常退出"><a href="#解决异常退出" class="headerlink" title="解决异常退出"></a>解决异常退出</h3><p>纯计算指令不能“停下来”，因此系统提供了一个指令syscall，系统调用。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">movq $SYS_exit,  %rax   # exit(</span><br><span class="line">movq $1,         %rdi   #   status=1</span><br><span class="line">syscall                 # );</span><br></pre></td></tr></table></figure>
<ul>
<li>把 “系统调用” 的参数放到寄存器中</li>
<li>执行 syscall，操作系统接管程序<ul>
<li>程序把控制权完全交给操作系统</li>
<li>操作系统可以改变程序状态甚至终止程序</li>
</ul>
</li>
</ul>
<p>实现真正的最小的Hello World，<strong>minimal.S</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/syscall.h&gt;</span><br><span class="line"></span><br><span class="line">.globl _start</span><br><span class="line">_start:</span><br><span class="line">  movq $SYS_write, %rax   // write(</span><br><span class="line">  movq $1,         %rdi   //   fd=1,</span><br><span class="line">  movq $st,        %rsi   //   buf=st,</span><br><span class="line">  movq $(ed - st), %rdx   //   count=ed-st</span><br><span class="line">  syscall                 // );</span><br><span class="line"></span><br><span class="line">  movq $SYS_exit,  %rax   // exit(</span><br><span class="line">  movq $1,         %rdi   //   status=1</span><br><span class="line">  syscall                 // );</span><br><span class="line"></span><br><span class="line">st:</span><br><span class="line">  .ascii &quot;\033[01;31mHello, OS World\033[0m\n&quot;</span><br><span class="line">ed:</span><br></pre></td></tr></table></figure>
<p>使用<code>gcc -c minimal.S</code>进行编译，<code>ld minimal.o</code>进行链接，Hello World就可以正常工作了，这个大小为4.65KB,使用<code>objdump -d a.out | wc -l</code>查看。仅32行。</p>
<p><img src="../img/image-28-169651743945630.png" alt="img">运行结果</p>
<p><img src="../img/image-29-169651743945632.png" alt="img">查看行数</p>
<p><img src="../img/image-30.png" alt="img">调试查看内容</p>
<h3 id="对一些细节的补充解释"><a href="#对一些细节的补充解释" class="headerlink" title="对一些细节的补充解释"></a>对一些细节的补充解释</h3><p>为什么用 gcc 编译？</p>
<ul>
<li>gcc 会进行预编译 (可以使用 <code>__ASSEMBLER__</code> 宏区分汇编/C 代码)</li>
</ul>
<p>ANSI Escape Code 的更多应用</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://git.busybox.net/busybox/tree/editors/vi.c">vi.c</a> from busybox</li>
<li><code>dialog --msgbox &#39;Hello, OS World!&#39; 8 32</code></li>
<li><code>ssh -o &#39;HostKeyAlgorithms +ssh-rsa&#39; sshtron.zachlatta.com</code></li>
</ul>
<h3 id="汇编代码的状态机模型"><a href="#汇编代码的状态机模型" class="headerlink" title="汇编代码的状态机模型"></a>汇编代码的状态机模型</h3><p>Everything is a state machine: 计算机 = 数字电路 = 状态机</p>
<p>所有的指令都只能计算</p>
<h2 id="理解高级语言程序"><a href="#理解高级语言程序" class="headerlink" title="理解高级语言程序"></a>理解高级语言程序</h2><h4 id="非递归汉诺塔实现"><a href="#非递归汉诺塔实现" class="headerlink" title="非递归汉诺塔实现"></a>非递归汉诺塔实现</h4><ul>
<li>hanoi-main.c</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;assert.h&gt;</span><br><span class="line"></span><br><span class="line">#include &quot;hanoi-nr.c&quot;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">  hanoi(3, &#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>一般使用递归解决hanoi-r.c</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void hanoi(int n, char from, char to, char via) &#123;</span><br><span class="line">  if (n == 1) &#123;</span><br><span class="line">    printf(&quot;%c -&gt; %c\n&quot;, from, to);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    hanoi(n - 1, from, via, to);</span><br><span class="line">    hanoi(1,     from, to,  via);</span><br><span class="line">    hanoi(n - 1, via,  to,  from);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>但是可以使用非递归进行实现</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">typedef struct &#123;</span><br><span class="line">  int pc, n;</span><br><span class="line">  char from, to, via;</span><br><span class="line">&#125; Frame;</span><br><span class="line"></span><br><span class="line">#define call(...) (&#123; *(++top) = (Frame) &#123; .pc = 0, __VA_ARGS__ &#125;; &#125;)</span><br><span class="line">#define ret()     (&#123; top--; &#125;)</span><br><span class="line">#define goto(loc) (&#123; f-&gt;pc = (loc) - 1; &#125;)</span><br><span class="line"></span><br><span class="line">void hanoi(int n, char from, char to, char via) &#123;</span><br><span class="line">  Frame stk[64], *top = stk - 1;</span><br><span class="line">  call(n, from, to, via);</span><br><span class="line">  for (Frame *f; (f = top) &gt;= stk; f-&gt;pc++) &#123;</span><br><span class="line">    n = f-&gt;n; from = f-&gt;from; to = f-&gt;to; via = f-&gt;via;</span><br><span class="line">    switch (f-&gt;pc) &#123;</span><br><span class="line">      case 0: if (n == 1) &#123; printf(&quot;%c -&gt; %c\n&quot;, from, to); goto(4); &#125; break;</span><br><span class="line">      case 1: call(n - 1, from, via, to);   break;</span><br><span class="line">      case 2: call(    1, from, to,  via);  break;</span><br><span class="line">      case 3: call(n - 1, via,  to,  from); break;</span><br><span class="line">      case 4: ret();                        break;</span><br><span class="line">      default: assert(0);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过与chatGPT的交流，可以了解该程序的实现原理。</p>
<p><img src="../img/image-31-169651743945635.png" alt="img">chatGPT理解的程序实现原理</p>
<p>对 C 程序做出简化</p>
<ul>
<li>简化：改写成每条语句至多一次运算/函数调用的形式<ul>
<li><a target="_blank" rel="noopener" href="https://cil-project.github.io/cil/">真的有这种工具</a> (C Intermediate Language) 和<a target="_blank" rel="noopener" href="https://gitlab.com/zsaleeba/picoc">解释器</a></li>
</ul>
</li>
</ul>
<p>状态机定义</p>
<ul>
<li>状态 = 堆 + 栈</li>
<li>初始状态 = <code>main</code> 的第一条语句</li>
<li>状态迁移 = 执行一条语句中的一小步</li>
</ul>
<h2 id="理解编译器"><a href="#理解编译器" class="headerlink" title="理解编译器"></a>理解编译器</h2><p>我们有两种状态机</p>
<ul>
<li><p>高级语言代码.</p>
<p>c</p>
<ul>
<li>状态：栈、全局变量；状态迁移：语句执行</li>
</ul>
</li>
<li><p>汇编指令序列.</p>
<p>s</p>
<ul>
<li>状态：(<em>M</em>,<em>R</em>)；状态迁移：指令执行</li>
</ul>
</li>
<li><p>编译器是二者之间的桥梁：.<em>s</em>=compile(.<em>c</em>)</p>
</li>
</ul>
<p>.<em>s</em>=compile(.<em>c</em>)：编译正确性</p>
<p>.<em>c</em> 执行中所有外部观测者可见的行为，必须在 .<em>s</em> 中保持一致</p>
<p>在此前提下，任何翻译都是合法的 (例如我们期望更快或更短的代码)</p>
<h2 id="操作系统上的软件-应用程序"><a href="#操作系统上的软件-应用程序" class="headerlink" title="操作系统上的软件 (应用程序)"></a>操作系统上的软件 (应用程序)</h2><h3 id="操作系统中的任何程序"><a href="#操作系统中的任何程序" class="headerlink" title="操作系统中的任何程序"></a>操作系统中的任何程序</h3><blockquote>
<p>任何程序 = minimal.S = 调用 syscall 的状态机</p>
</blockquote>
<p>可执行文件是操作系统中的对象</p>
<ul>
<li>与大家日常使用的文件 (a.c, README.txt) 没有本质区别</li>
<li>操作系统提供 API 打开、读取、改写 (都需要相应的权限)</li>
</ul>
<p>查看可执行文件</p>
<ul>
<li><pre><code>vim
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">, </span><br><span class="line"></span><br></pre></td></tr></table></figure>
cat
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">, </span><br><span class="line"></span><br></pre></td></tr></table></figure>
xxd
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   都可以直接 “查看” 可执行文件</span><br><span class="line"></span><br><span class="line">  - `vim` 中二进制的部分无法 “阅读”，但可以看到字符串常量</span><br><span class="line">  - 使用 `xxd` 可以看到文件以 `&quot;\x7f&quot; &quot;ELF&quot;` 开头</span><br><span class="line">  - Vscode 有 binary editor 插件</span><br><span class="line"></span><br><span class="line">尝试使用文本编辑器打开之前的最小Hello World程序，可以在里面找到对应的字样。</span><br><span class="line"></span><br><span class="line">![img](../img/image-32-1024x593.png)使用文本编辑器查看a.out</span><br><span class="line"></span><br><span class="line">在vim中使用命令`:%!xxd`，实现编辑区域中文本传递中到xxd。</span><br><span class="line"></span><br><span class="line">![img](../img/image-33-169651743945638.png)处理后</span><br><span class="line"></span><br><span class="line">### 系统中常见的应用程序</span><br><span class="line"></span><br><span class="line">Core Utilities (coreutils)</span><br><span class="line"></span><br><span class="line">- *Standard* programs for text and file manipulation</span><br><span class="line"></span><br><span class="line">- 系统中安装的是 </span><br><span class="line"></span><br><span class="line">  GNU Coreutils</span><br><span class="line"></span><br><span class="line">  - 有较小的替代品 [busybox](https://www.busybox.net/)</span><br><span class="line"></span><br><span class="line">系统/工具程序</span><br><span class="line"></span><br><span class="line">- bash, </span><br><span class="line"></span><br><span class="line">  binutils</span><br><span class="line"></span><br><span class="line">  , apt, ip, ssh, vim, tmux, jdk, python, ...</span><br><span class="line"></span><br><span class="line">  - 这些工具的原理不复杂 (例如 apt 是 dpkg 的套壳)，但琐碎</span><br><span class="line">  - [Ubuntu Packages](https://packages.ubuntu.com/) (和 apt-file 工具) 支持文件名检索</span><br><span class="line"></span><br><span class="line">其他各种应用程序</span><br><span class="line"></span><br><span class="line">- Vscode, 浏览器、音乐播放器……</span><br><span class="line"></span><br><span class="line">### 打开程序的执行：Trace (追踪)</span><br><span class="line"></span><br><span class="line">使用strace ./a.out进行追踪程序的系统调用。</span><br><span class="line"></span><br><span class="line">![img](../img/image-34.png)strace</span><br><span class="line"></span><br><span class="line">### 操作系统中 “任何程序” 的一生</span><br><span class="line"></span><br><span class="line">&gt; 任何程序 = minimal.S = 调用 syscall 的状态机</span><br><span class="line"></span><br><span class="line">## 总结</span><br><span class="line"></span><br><span class="line">无论是汇编代码还是高级语言程序，它们都可以表示成状态机：</span><br><span class="line"></span><br><span class="line">- 高级语言代码 .c</span><br><span class="line">  - 状态：栈、全局变量；状态迁移：语句执行</span><br><span class="line">- 汇编指令序列 .s</span><br><span class="line">  - 状态：(M,R)；状态迁移：指令执行</span><br><span class="line">- 编译器实现了两种状态机之间的翻译</span><br><span class="line"></span><br><span class="line">应用程序与操作系统沟通的唯一桥梁是系统调用指令 (例如 x86-64 的 syscall)。计算机系统不存在玄学；一切都建立在确定的机制上。</span><br><span class="line"></span><br><span class="line">- 理解操作系统的重要工具：gcc, binutils, gdb, strace。</span><br><span class="line"></span><br><span class="line"># 绪论3_硬件视角的操作系统_2023.2.28</span><br><span class="line"></span><br><span class="line">## 回顾：计算机硬件</span><br><span class="line"></span><br><span class="line">### 计算机硬件 = 数字电路</span><br><span class="line"></span><br><span class="line">基本构件：wire, reg, NAND</span><br><span class="line"></span><br><span class="line">程序是 “严格的数学对象”</span><br><span class="line"></span><br><span class="line">不仅是程序，整个计算机系统也是一个状态机</span><br><span class="line"></span><br><span class="line">- 状态：内存和寄存器数值</span><br><span class="line">- **初始状态**：手册规定 (CPU Reset)</span><br><span class="line">- 状态迁移</span><br><span class="line">  - 任意选择一个处理器 cpu</span><br><span class="line">  - 响应处理器外部中断</span><br><span class="line">  - 从 cpu.PC 取指令执行</span><br><span class="line"></span><br><span class="line">## 硬件与程序员的约定</span><br><span class="line"></span><br><span class="line">Bare-metal 与厂商的约定</span><br><span class="line"></span><br><span class="line">- CPU Reset 后的状态</span><br><span class="line"></span><br><span class="line">   (寄存器值)</span><br><span class="line"></span><br><span class="line">  - 厂商自由处理这个地址上的值</span><br><span class="line">  - Memory-mapped I/O</span><br><span class="line"></span><br><span class="line">厂商为操作系统开发者提供 Firmware</span><br><span class="line"></span><br><span class="line">- 管理硬件和系统配置</span><br><span class="line">- 把存储设备上的代码加载到内存</span><br><span class="line">  - 例如存储介质上的第二级 loader (加载器)</span><br><span class="line">  - 或者直接加载操作系统 (嵌入式系统)</span><br><span class="line"></span><br><span class="line">### x86 Family: CPU Reset</span><br><span class="line"></span><br><span class="line">![img](../img/image-102-797x1024.png)intel-cpu-reset</span><br><span class="line"></span><br><span class="line">- 寄存器会有确定的初始状态</span><br><span class="line"></span><br><span class="line">  - `EIP = 0x0000fff0`</span><br><span class="line"></span><br><span class="line">  - ```</span><br><span class="line">    CR0 = 0x60000010</span><br></pre></td></tr></table></figure>

  - 处理器处于 16-bit 模式

-
</code></pre><p>  EFLAGS = 0x00000002</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    - Interrupt disabled</span><br><span class="line"></span><br><span class="line">- TFM (5,000 页+)</span><br><span class="line"></span><br><span class="line">  - 最需要的 Volume 3A 只有 ~400 页 (我们更需要 AI)</span><br><span class="line"></span><br><span class="line">### 其他平台上的 CPU Reset</span><br><span class="line"></span><br><span class="line">Reset 后处理器都从固定地址 (Reset Vector) 启动</span><br><span class="line"></span><br><span class="line">- MIPS: 0xbfc00000</span><br><span class="line">  - Specification 规定</span><br><span class="line">- ARM: 0x00000000</span><br><span class="line">  - Specification 规定</span><br><span class="line">  - 允许配置 Reset Vector Base Address Register</span><br><span class="line">- RISC-V: Implementation defined</span><br><span class="line">  - 给厂商最大程度的自由</span><br><span class="line"></span><br><span class="line">Firmware 负责加载操作系统</span><br><span class="line"></span><br><span class="line">- 开发板：直接把加载器写入 ROM</span><br><span class="line">- QEMU：`-kernel` 可以绕过 Firmware 直接加载内核 ([RTFM](https://www.qemu.org/docs/master/system/invocation.html#hxtool-8))</span><br><span class="line"></span><br><span class="line">### x86 CPU Reset 之后：到底执行了什么？</span><br><span class="line"></span><br><span class="line">![img](../img/image-103.png)bios-firmware</span><br><span class="line"></span><br><span class="line">状态机 (初始状态) 开始执行</span><br><span class="line"></span><br><span class="line">- 从 PC 取指令、译码、执行……</span><br><span class="line">- 开始执行厂商 “安排好” 的 Firmware 代码</span><br><span class="line">  - x86 Reset Vector 是一条向 Firmware 跳转的 jmp 指令</span><br><span class="line"></span><br><span class="line">Firmware: [BIOS vs. UEFI](https://www.zhihu.com/question/21672895)</span><br><span class="line"></span><br><span class="line">- 一个小 “操作系统”</span><br><span class="line">  - 管理、配置硬件；加载操作系统</span><br><span class="line">- Legacy BIOS (Basic I/O System)</span><br><span class="line">  - IBM PC 所有设备/BIOS 中断是有 specification 的 (成就了 “兼容机”)</span><br><span class="line">- UEFI (Unified Extensible Firmware Interface)</span><br><span class="line"></span><br><span class="line">### 为什么需要 UEFI？</span><br><span class="line"></span><br><span class="line">今天的 Firmware 面临麻烦得多的硬件：</span><br><span class="line"></span><br><span class="line">- 指纹锁、USB 转接器上的 Linux-to-Go 优盘、山寨网卡上的 PXE 网络启动、USB 蓝牙转接器连接的蓝牙键盘、……</span><br><span class="line">  - 这些设备都需要 “驱动程序” 才能访问</span><br><span class="line">  - 解决 BIOS 逐渐碎片化的问题</span><br><span class="line"></span><br><span class="line">![img](../img/image-104-1024x695.png)UEFI-booting-seq</span><br><span class="line"></span><br><span class="line">### 回到 Legacy BIOS: 约定</span><br><span class="line"></span><br><span class="line">BIOS 提供机制，将**程序员的代码**载入内存</span><br><span class="line"></span><br><span class="line">- Legacy BIOS 把第一个可引导设备的第一个 </span><br><span class="line"></span><br><span class="line">  512 </span><br><span class="line"></span><br><span class="line">  字节加载到物理内存的 </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>7c00</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> 位置</span><br><span class="line"></span><br><span class="line">- 此时处理器处于 16-bit 模式</span><br><span class="line"></span><br><span class="line">- 规定 </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>  CS:IP = 0x7c00</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">, </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>  (R[CS] &lt;&lt; 4) | R[IP] == 0x7c00</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    - 可能性1：`CS = 0x07c0, IP = 0`</span><br><span class="line">    - 可能性2：`CS = 0, IP = 0x7c00`</span><br><span class="line"></span><br><span class="line">  - 其他没有任何约束</span><br><span class="line"></span><br><span class="line">虽然最多只有 446 字节代码 (64B 分区表 + 2B 标识)</span><br><span class="line"></span><br><span class="line">- 但控制权已经回到程序员手中了！</span><br><span class="line">- 你甚至可以让 ChatGPT 给你写一个 Hello World</span><br><span class="line">  - 当然，他是抄作业的 (而且是有些小问题的)</span><br><span class="line"></span><br><span class="line">计算机系统公理：你想到的就一定有人做到</span><br><span class="line"></span><br><span class="line">- 模拟方案：QEMU</span><br><span class="line"></span><br><span class="line">  - 传奇黑客、天才程序员 </span><br><span class="line"></span><br><span class="line">    Fabrice Bellard</span><br><span class="line"></span><br><span class="line">     的杰作</span><br><span class="line"></span><br><span class="line">    - [QEMU, A fast and portable dynamic translator](https://www.usenix.org/legacy/publications/library/proceedings/usenix05/tech/freenix/full_papers/bellard/bellard.pdf) (USENIX ATC&#x27;05)</span><br><span class="line">    - Android Virtual Device, VirtualBox, ... 背后都是 QEMU</span><br><span class="line"></span><br><span class="line">- 真机方案：JTAG (Joint Test Action Group) debugger</span><br><span class="line"></span><br><span class="line">  - 一系列 (物理) 调试寄存器，可以实现 gdb 接口 (!!!) </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- Makefile</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>mbr.img: mbr.S<br>  gcc -ggdb -c $&lt;<br>  ld mbr.o -Ttext 0x7c00<br>  objcopy -S -O binary -j .text a.out $@</p>
</li>
</ul>
<p>run: mbr.img<br>    qemu-system-x86_64 $&lt;</p>
<p>debug: mbr.img<br>    qemu-system-x86_64 -s -S $&lt; &amp;  # Run QEMU in background<br>    gdb -x init.gdb  # RTFM: gdb (1)</p>
<p>clean:<br>    rm -f <em>.img </em>.o a.out<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- mbr.S</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h1 id="define-SECT-SIZE-512"><a href="#define-SECT-SIZE-512" class="headerlink" title="define SECT_SIZE  512"></a>define SECT_SIZE  512</h1><p>.code16  // 16-bit assembly</p>
<p>// Entry of the code<br>.globl _start<br>_start:<br>  lea   (msg), %si   // R[si] = &msg;</p>
<p>again:<br>  movb  (%si), %al   // R[al] = *R[si]; &lt;—+<br>  incw  %si          // R[si]++;           |<br>  orb   %al, %al     // if (!R[al])        |<br>  jz    done         //   goto done; —+   |<br>  movb  $0x0e, %ah   // R[ah] = 0x0e;  |   |<br>  movb  $0x00, %bh   // R[bh] = 0x00;  |   |<br>  int   $0x10        // bios_call();   |   |<br>  jmp   again        // goto again; —-+—-+<br>                     //                |<br>done:                //                |<br>  jmp   .            // goto done; &lt;—-+</p>
<p>// Data: const char msg[] = “…”;<br>msg:<br>  .asciz “This is a baby step towards operating systems!\r\n”</p>
<p>// Magic number for bootable device<br>.org SECT_SIZE - 2<br>.byte 0x55, 0xAA<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- init.gdb</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h1 id="Kill-process-QEMU-on-gdb-exits"><a href="#Kill-process-QEMU-on-gdb-exits" class="headerlink" title="Kill process (QEMU) on gdb exits"></a>Kill process (QEMU) on gdb exits</h1><p>define hook-quit<br>  kill<br>end</p>
<h1 id="Connect-to-remote"><a href="#Connect-to-remote" class="headerlink" title="Connect to remote"></a>Connect to remote</h1><p>target remote localhost:1234<br>file a.out<br>break *0x7c00<br>layout src<br>continue<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">运行make run可以看到结果，编译生成的mbr.img大小为512字节。</span><br><span class="line"></span><br><span class="line">![img](../img/image.png)运行</span><br><span class="line"></span><br><span class="line">注意得要先安装一个qemu，命令`sudo apt-get install qemu-system-x86`。</span><br><span class="line"></span><br><span class="line">由于已经写好脚本，可以使用`make debug`便捷启动debug。</span><br><span class="line"></span><br><span class="line">![img](../img/image-1-1024x401.png)debug</span><br><span class="line"></span><br><span class="line">### UEFI 上的操作系统加载</span><br><span class="line"></span><br><span class="line">标准化的加载流程</span><br><span class="line"></span><br><span class="line">- 磁盘必须按 GPT (GUID Partition Table) 方式格式化</span><br><span class="line"></span><br><span class="line">- 预留一个 FAT32 分区 (lsblk/fdisk 可以看到)</span><br><span class="line"></span><br><span class="line">- Firmware 能够加载任意大小的 PE 可执行文件 </span><br><span class="line"></span><br></pre></td></tr></table></figure><br>  .efi<br>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  - 没有 legacy boot 512 字节限制</span><br><span class="line">  - EFI 应用可以返回 firmware</span><br><span class="line"></span><br><span class="line">更好的程序支持</span><br><span class="line"></span><br><span class="line">- 设备驱动框架</span><br><span class="line">- 更多的功能，例如 Secure Boot，只能启动 “信任” 的操作系统</span><br><span class="line"></span><br><span class="line">## 实现最小 “操作系统”</span><br><span class="line"></span><br><span class="line">### 我们已经获得的能力</span><br><span class="line"></span><br><span class="line">为硬件直接编程</span><br><span class="line"></span><br><span class="line">- 可以让机器运行任意不超过 510 字节的指令序列</span><br><span class="line">- 编写任何指令序列 (状态机)</span><br><span class="line">  - 只要能问出问题，就可以 RTFM/STFW/ChatGPT 找到答案</span><br><span class="line">    - “如何在汇编里生成 *n* 个字节的 0”</span><br><span class="line">    - “如何在 x86 16-bit mode 打印字符”</span><br><span class="line"></span><br><span class="line">操作系统：就一个 C 程序</span><br><span class="line"></span><br><span class="line">- 用 510 字节的指令完成磁盘 → 内存的加载</span><br><span class="line">- 初始化 C 程序的执行环境</span><br><span class="line">- 操作系统就开始运行了！</span><br><span class="line"></span><br><span class="line">### Bare-metal 上的 C 代码</span><br><span class="line"></span><br><span class="line">为了让下列程序能够 “运行起来”：</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>int main() {<br>  printf(“Hello, World\n”);<br>}<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">我们需要准备什么？</span><br><span class="line"></span><br><span class="line">- MBR 上的 “启动加载器” (Boot Loader)</span><br><span class="line">- 我们可以通过编译器控制 C 程序的行为</span><br><span class="line">  - 静态链接/PIC (位置无关代码)</span><br><span class="line">  - Freestanding (不使用任何标准库)</span><br><span class="line">  - 自己手工实现库函数 (putch, printf, ...)</span><br><span class="line">    - 有亿点点细节：RTFSC!</span><br><span class="line"></span><br><span class="line">- hello.c</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h1 id="include"><a href="#include" class="headerlink" title="include "></a>include <am.h></h1><h1 id="define-ESC-“-033-“"><a href="#define-ESC-“-033-“" class="headerlink" title="define ESC “\033[“"></a>define ESC “\033[“</h1><h1 id="define-RED-ESC-“01-31m”"><a href="#define-RED-ESC-“01-31m”" class="headerlink" title="define RED ESC “01;31m”"></a>define RED ESC “01;31m”</h1><h1 id="define-CLR-ESC-“0m”"><a href="#define-CLR-ESC-“0m”" class="headerlink" title="define CLR ESC “0m”"></a>define CLR ESC “0m”</h1><p>const char *MESSAGE = RED “Hello, OS World\n” CLR;</p>
<p>int main() {<br>  for (const char <em>s = MESSAGE; </em>s; s++) {<br>    putch(*s);  // Prints to platform-dependent debug console<br>  }<br>}<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- kernel.c</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h1 id="include-1"><a href="#include-1" class="headerlink" title="include "></a>include <am.h></h1><h1 id="include-2"><a href="#include-2" class="headerlink" title="include "></a>include <klib.h></h1><h1 id="include-3"><a href="#include-3" class="headerlink" title="include "></a>include <klib-macros.h></h1><p>typedef union task {<br>  struct {<br>    const char <em>name;<br>    union task </em>next;<br>    void      (<em>entry)(void </em>);<br>    Context    *context;<br>  };<br>  uint8_t stack[8192];<br>} Task;</p>
<p>Task *current;</p>
<p>void func(void <em>arg) {<br>  while (1) {<br>    putch(</em>(char *)arg);<br>    for (int volatile i = 0; i &lt; 100000; i++) ;<br>  }<br>}</p>
<p>Task tasks[] = {<br>  { .name = “a”, .entry = func },<br>  { .name = “b”, .entry = func },<br>};</p>
<p>Context <em>on_interrupt(Event ev, Context </em>ctx) {<br>  if (!current) {<br>    current = &amp;tasks[0];<br>  } else {<br>    current-&gt;context = ctx;<br>  }<br>  return (current = current-&gt;next)-&gt;context;<br>}</p>
<p>int main() {<br>  cte_init(on_interrupt);  // call on_interrupt() on traps/interrupts</p>
<p>  for (int i = 0; i &lt; LENGTH(tasks); i++) {<br>    Task <em>task    = &amp;tasks[i];<br>    Area stack    = (Area) { &amp;task-&gt;context + 1, task + 1 };<br>    task-&gt;context = kcontext(stack, task-&gt;entry, (void </em>)task-&gt;name);<br>    task-&gt;next    = &amp;tasks[(i + 1) % LENGTH(tasks)];<br>  }<br>  iset(true);  // Enable external interrupts (timer, I/O, …)<br>  yield();  // Trap<br>}<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- Makefile</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>NAME := hello<br>SRCS := hello.c<br>export ARCH := x86_64-qemu</p>
<p>include $(AM_HOME)/Makefile<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">![img](../img/image-2-169651743945646.png)运行结果</span><br><span class="line"></span><br><span class="line">运行这段代码，我们需要设置 `AM_HOME` 环境变量为实验框架代码中的 AbstractMachine 所在目录 (绝对路径)</span><br><span class="line"></span><br><span class="line">框架地址：[NJU-ProjectN/abstract-machine: A minimal, modularized, and machine-independent hardware abstraction layer (github.com)](https://github.com/NJU-ProjectN/abstract-machine)</span><br><span class="line"></span><br><span class="line">设置方法：`vim ~/.bashrc ` ，然后添加`export AM_HOME=绝对路径`  ，然后按Esc, :wq, 回车，然后`source ~/.bashrc`即可生效。</span><br><span class="line"></span><br><span class="line">坑：可能出现报错：</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>/usr/include/stdint.h:26:10: fatal error: bits/libc-header-start.h: No such file or directory<br>   26 | #include <bits/libc-header-start.h><br>      |<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">原因：编译的项目是在64位机器上生成32位的项目，你需要安装对应的gcc 32位的库</span><br><span class="line"></span><br><span class="line">解决：`sudo apt install gcc-multilib`</span><br><span class="line"></span><br><span class="line">对于vscode的&lt;am.h&gt;头文件报红，可以使用快速修复解决。（因此建议将其放在同一项目文件夹下）</span><br><span class="line"></span><br><span class="line">![img](../img/image-3-169651743945648.png)快速修复</span><br><span class="line"></span><br><span class="line">![img](../img/image-4-1024x435.png)自动添加</span><br><span class="line"></span><br><span class="line"># 绪论4_Python实现操作系统模型_2023.3.2</span><br><span class="line"></span><br><span class="line">## 理解操作系统的新途径</span><br><span class="line"></span><br><span class="line">### 回顾：程序/硬件的状态机模型</span><br><span class="line"></span><br><span class="line">计算机软件</span><br><span class="line"></span><br><span class="line">- 状态机 (C/汇编)</span><br><span class="line">  - 允许执行特殊指令 (syscall) 请求操作系统</span><br><span class="line">  - 操作系统 = API + 对象</span><br><span class="line"></span><br><span class="line">计算机硬件</span><br><span class="line"></span><br><span class="line">- “无情执行指令的机器”</span><br><span class="line">  - 从 CPU Reset 状态开始执行 Firmware 代码</span><br><span class="line">  - 操作系统 = C 程序</span><br><span class="line"></span><br><span class="line">### 一个大胆的想法</span><br><span class="line"></span><br><span class="line">无论是软件还是硬件，都是状态机</span><br><span class="line"></span><br><span class="line">- 而状态和状态的迁移是可以 “画” 出来的！</span><br><span class="line">- 理论上说，只需要两个 API</span><br><span class="line">  - `dump_state()` - 获取当前程序状态</span><br><span class="line">  - `single_step()` - 执行一步</span><br><span class="line">  - gdb 不就是做这个的吗！</span><br><span class="line"></span><br><span class="line">## 操作系统 “玩具”：设计与实现</span><br><span class="line"></span><br><span class="line">### 操作系统玩具：API</span><br><span class="line"></span><br><span class="line">四个 “系统调用” API</span><br><span class="line"></span><br><span class="line">- choose(xs): 返回 `xs` 中的一个随机选项</span><br><span class="line">- write(s): 输出字符串 `s`</span><br><span class="line">- spawn(fn): 创建一个可运行的状态机 `fn`</span><br><span class="line">- sched(): 随机切换到任意状态机执行</span><br><span class="line"></span><br><span class="line">除此之外，所有的代码都是确定 (deterministic) 的纯粹计算</span><br><span class="line"></span><br><span class="line">- 允许使用 list, dict 等数据结构</span><br><span class="line"></span><br><span class="line">软件就是状态机，操作系统是状态机的管理者。</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>count = 0</p>
<p>def Tprint(name):<br>    global count<br>    for i in range(3):<br>        count += 1<br>        sys_write(f’#{count:02} Hello from {name}{i+1}\n’)<br>        sys_sched()</p>
<p>def main():<br>    n = sys_choose([3, 4, 5])<br>    sys_write(f’#Thread = {n}\n’)<br>    for name in ‘ABCDE’[:n]:<br>        sys_spawn(Tprint, name)<br>    sys_sched()<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 实现系统调用</span><br><span class="line"></span><br><span class="line">有些 “系统调用” 的实现是显而易见的</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>def sys_write(s): print(s)<br>def sys_choose(xs): return random.choice(xs)<br>def sys_spawn(t): runnables.append(t)<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">有些就困难了</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>def sys_sched():<br>    raise NotImplementedError(‘No idea how’)<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">我们需要</span><br><span class="line"></span><br><span class="line">- 封存当前状态机的状态</span><br><span class="line">- 恢复另一个 “被封存” 状态机的执行</span><br><span class="line">  - 没错，我们离真正的 “分时操作系统” 就只差这一步</span><br><span class="line"></span><br><span class="line">### 借用 Python 的语言机制</span><br><span class="line"></span><br><span class="line">Generator objects (无栈协程/轻量级线程/...)</span><br><span class="line"></span><br><span class="line">利用了yield</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>def numbers():<br>    i = 0<br>    while True:<br>        ret = yield f’{i:b}’  # “封存” 状态机状态<br>        i += ret<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">使用方法：</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>n = numbers()  # 封存状态机初始状态<br>n.send(None)  # 恢复封存的状态<br>n.send(0)  # 恢复封存的状态 (并传入返回值)<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">![img](../img/image-6-169651743945751.png)generator</span><br><span class="line"></span><br><span class="line">![img](../img/image-7.png)send，以二进制结果输出</span><br><span class="line"></span><br><span class="line">![img](../img/image-8-16965174394401.png)另外开一个线程m，切换</span><br><span class="line"></span><br><span class="line">- os-model.py</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h1 id="usr-bin-env-python3"><a href="#usr-bin-env-python3" class="headerlink" title="!/usr/bin/env python3"></a>!/usr/bin/env python3</h1><p>import sys<br>import random<br>from pathlib import Path</p>
<p>class OperatingSystem():<br>    “””A minimal executable operating system model.”””</p>
<pre><code>SYSCALLS = [&#39;choose&#39;, &#39;write&#39;, &#39;spawn&#39;, &#39;sched&#39;]

class Thread:
    &quot;&quot;&quot;A &quot;freezed&quot; thread state.&quot;&quot;&quot;

    def __init__(self, func, *args):
        self._func = func(*args)
        self.retval = None

    def step(self):
        &quot;&quot;&quot;Proceed with the thread until its next trap.&quot;&quot;&quot;
        syscall, args, *_ = self._func.send(self.retval)
        self.retval = None
        return syscall, args

def __init__(self, src):
    variables = &#123;&#125;
    exec(src, variables)
    self._main = variables[&#39;main&#39;]

def run(self):
    threads = [OperatingSystem.Thread(self._main)]
    while threads:  # Any thread lives
        try:
            match (t := threads[0]).step():
                case &#39;choose&#39;, xs:  # Return a random choice
                    t.retval = random.choice(xs)
                case &#39;write&#39;, xs:  # Write to debug console
                    print(xs, end=&#39;&#39;)
                case &#39;spawn&#39;, (fn, args):  # Spawn a new thread
                    threads += [OperatingSystem.Thread(fn, *args)]
                case &#39;sched&#39;, _:  # Non-deterministic schedule
                    random.shuffle(threads)
        except StopIteration:  # A thread terminates
            threads.remove(t)
            random.shuffle(threads)  # sys_sched()
</code></pre><p>if <strong>name</strong> == ‘<strong>main</strong>‘:<br>    if len(sys.argv) &lt; 2:<br>        print(f’Usage: {sys.argv[0]} file’)<br>        exit(1)</p>
<pre><code>src = Path(sys.argv[1]).read_text()
for syscall in OperatingSystem.SYSCALLS:
    src = src.replace(f&#39;sys_&#123;syscall&#125;&#39;,        # sys_write(...)
                      f&#39;yield &quot;&#123;syscall&#125;&quot;, &#39;)  #  -&gt; yield &#39;write&#39;, (...)

OperatingSystem(src).run()
</code></pre><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- hello.py</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>def main():<br>    sys_write(‘Hello, OS World\n’)  # sys_write -&gt; print<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">![img](../img/image-9-169651743945855.png)调用结果</span><br><span class="line"></span><br><span class="line">- threads.py</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>count = 0</p>
<p>def Tprint(name):<br>    global count<br>    for i in range(3):<br>        count += 1<br>        sys_write(f’#{count:02} Hello from {name}{i+1}\n’)<br>        sys_sched()</p>
<p>def main():<br>    n = sys_choose([3, 4, 5])<br>    sys_write(f’#Thread = {n}\n’)<br>    for name in ‘ABCDE’[:n]:<br>        sys_spawn(Tprint, name)<br>    sys_sched()<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">![img](../img/image-10-16965174394402.png)threads</span><br><span class="line"></span><br><span class="line">## 建模操作系统</span><br><span class="line"></span><br><span class="line">### 一个更 “全面” 的操作系统模型</span><br><span class="line"></span><br><span class="line">进程 + 线程 + 终端 + 存储 (崩溃一致性)</span><br><span class="line"></span><br><span class="line">| 系统调用/Linux 对应          | 行为                           |</span><br><span class="line">| ---------------------------- | ------------------------------ |</span><br><span class="line">| sys_spawn(fn)/pthread_create | 创建从 fn 开始执行的线程       |</span><br><span class="line">| sys_fork()/fork              | 创建当前状态机的完整复制       |</span><br><span class="line">| sys_sched()/定时被动调用     | 切换到随机的线程/进程执行      |</span><br><span class="line">| sys_choose(xs)/rand          | 返回一个 xs 中的随机的选择     |</span><br><span class="line">| sys_write(s)/printf          | 向调试终端输出字符串 s         |</span><br><span class="line">| sys_bread(k)/read            | 读取虚拟设磁盘块 *k* 的数据    |</span><br><span class="line">| sys_bwrite(k, v)/write       | 向虚拟磁盘块 *k* 写入数据 *v*  |</span><br><span class="line">| sys_sync()/sync              | 将所有向虚拟磁盘的数据写入落盘 |</span><br><span class="line">| sys_crash()/长按电源按键     | 模拟系统崩溃                   |</span><br><span class="line"></span><br><span class="line">行为</span><br><span class="line"></span><br><span class="line">### 模型做出的简化</span><br><span class="line"></span><br><span class="line">被动进程/线程切换</span><br><span class="line"></span><br><span class="line">- 实际程序随时都可能被动调用 `sys_sched()` 切换</span><br><span class="line"></span><br><span class="line">只有一个终端</span><br><span class="line"></span><br><span class="line">- 没有 `read()` (用 choose 替代 “允许读到任意值”)</span><br><span class="line"></span><br><span class="line">磁盘是一个 `dict`</span><br><span class="line"></span><br><span class="line">- 把任意 key 映射到任意 value</span><br><span class="line">- 实际的磁盘</span><br><span class="line">  - key 为整数</span><br><span class="line">  - value 是固定大小 (例如 4KB) 的数据</span><br><span class="line">  - 二者在某种程度上是可以 “互相转换” 的</span><br><span class="line"></span><br><span class="line">### 模型实现</span><br><span class="line"></span><br><span class="line">原理与刚才的 “最小操作系统玩具” 类似</span><br><span class="line"></span><br><span class="line">- [mosaic.py](https://jyywiki.cn/pages/OS/2023/mosaic/mosaic.py) - 500 行建模操作系统</span><br><span class="line">- 进程/线程都是 Generator Object</span><br><span class="line">- 共享内存用 heap 变量访问</span><br><span class="line">  - 线程会得到共享 heap 的指针</span><br><span class="line">  - 进程会得到一个独立的 heap clone</span><br><span class="line"></span><br><span class="line">输出程序运行的 “状态图”</span><br><span class="line"></span><br><span class="line">- JSON Object</span><br><span class="line">- Vertices: 线程/进程、内存快照、设备历史输出</span><br><span class="line">- Edges: 系统调用</span><br><span class="line">  - 操作系统就是 “状态机的管理者”</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- mosaic.py</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h1 id="usr-bin-env-python3-1"><a href="#usr-bin-env-python3-1" class="headerlink" title="!/usr/bin/env python3"></a>!/usr/bin/env python3</h1><h1 id="Mosaic-Emulator-and-Checker"><a href="#Mosaic-Emulator-and-Checker" class="headerlink" title="Mosaic Emulator and Checker"></a>Mosaic Emulator and Checker</h1><p>import argparse<br>import ast<br>import copy<br>import inspect<br>import json<br>import random<br>from dataclasses import dataclass<br>from itertools import compress, product<br>from pathlib import Path<br>from typing import Callable, Generator</p>
<h2 id="1-Mosaic-system-calls"><a href="#1-Mosaic-system-calls" class="headerlink" title="1. Mosaic system calls"></a>1. Mosaic system calls</h2><h3 id="1-1-Process-thread-and-context-switching"><a href="#1-1-Process-thread-and-context-switching" class="headerlink" title="1.1 Process, thread, and context switching"></a>1.1 Process, thread, and context switching</h3><p>sys_fork = lambda: os.sys_fork()<br>sys_spawn = lambda fn, <em>args: os.sys_spawn(fn, </em>args)<br>sys_sched = lambda: os.sys_sched()</p>
<h3 id="1-2-Virtual-character-device"><a href="#1-2-Virtual-character-device" class="headerlink" title="1.2 Virtual character device"></a>1.2 Virtual character device</h3><p>sys_choose = lambda choices: os.sys_choose(choices)<br>sys_write = lambda <em>args: os.sys_write(</em>args)</p>
<h3 id="1-3-Virtual-block-storage-device"><a href="#1-3-Virtual-block-storage-device" class="headerlink" title="1.3 Virtual block storage device"></a>1.3 Virtual block storage device</h3><p>sys_bread = lambda k: os.sys_bread(k)<br>sys_bwrite = lambda k, v: os.sys_bwrite(k, v)<br>sys_sync = lambda: os.sys_sync()<br>sys_crash = lambda: os.sys_crash()</p>
<h3 id="1-4-System-call-helpers"><a href="#1-4-System-call-helpers" class="headerlink" title="1.4 System call helpers"></a>1.4 System call helpers</h3><p>SYSCALLS = []</p>
<p>def syscall(func):  # @syscall decorator<br>    SYSCALLS.append(func.<strong>name</strong>)<br>    return func</p>
<h2 id="2-Mosaic-operating-system-emulator"><a href="#2-Mosaic-operating-system-emulator" class="headerlink" title="2. Mosaic operating system emulator"></a>2. Mosaic operating system emulator</h2><h3 id="2-1-Data-structures"><a href="#2-1-Data-structures" class="headerlink" title="2.1 Data structures"></a>2.1 Data structures</h3><p>class Heap:<br>    pass  # no member: self.<strong>dict</strong> is the heap</p>
<p>@dataclass<br>class Thread:<br>    context: Generator  # program counter, local variables, etc.<br>    heap: Heap  # a pointer to thread’s “memory”</p>
<p>@dataclass<br>class Storage:<br>    persist: dict  # persisted storage state<br>    buf: dict  # outstanding operations yet to be persisted</p>
<h3 id="2-2-The-OperatingSystem-class"><a href="#2-2-The-OperatingSystem-class" class="headerlink" title="2.2 The OperatingSystem class"></a>2.2 The OperatingSystem class</h3><p>class OperatingSystem:<br>    “””An executable operating system model.</p>
<pre><code>The operating system model hosts a single Python application with a
main() function accessible to a shared heap and 9 system calls
(marked by the @syscall decorator). An example:

    def main():
        pid = sys_fork()
        sys_sched()  # non-deterministic context switch
        if pid == 0:
            sys_write(&#39;World&#39;)
        else:
            sys_write(&#39;Hello&#39;)

At any moment, this model keeps tracking a set of threads and a
&quot;currently running&quot; one. Each thread consists of a reference to a
heap object (may be shared with other threads) and a private context
(program counters, local variables, etc.). A thread context is a
Python generator object, i.e., a stack-less coroutine [1] that can
save the running context and yield itself.

For applications, the keyword &quot;yield&quot; is reserved for system calls.
For example, a &quot;choose&quot; system call [2]:

    sys_choose([&#39;A&#39;, &#39;B&#39;])

is transpiled as yielding the string &quot;sys_choose&quot; followed by its
parameters (choices):

    res = yield &#39;sys_choose&#39;, [&#39;A&#39;, &#39;B&#39;].

Yield will transfer the control to the OS for system call handling
and eventually returning a value (&#39;A&#39; or &#39;B&#39;) to the application.

Right after transferring control to the OS by &quot;yield&quot;, the function
state is &quot;frozen&quot;, where program counters and local variables are
accessible via the generator object. Therefore, OS can serialize its
internal state--all thread&#39;s contexts, heaps, and virtual device
states at this moment.

In this sense, operating system is a system-call driven state
transition system:

    (s0) --run first thread (main)-&gt; (s1)
         --sys_choose and application execution-&gt; (s2)
         --sys_sched and application execution-&gt; (s3) ...

Real operating systems can be preemptive--context switching can
happen non-deterministically at any program point, simply because
processor can non-deterministically interrupt its currently running
code and transfer the control to the operating system.

The OS internal implementation does NOT immediately process the
system call: it returns all possible choices available at the moment
and their corresponding processing logic as callbacks. For the
example above, the &quot;choose&quot; system call returns a non-deterministic
choice among given choices. The internal implementation thus returns

    choices = &#123;
        &#39;A&#39;: (lambda: &#39;A&#39;),
        &#39;B&#39;: (lambda: &#39;B&#39;),
    &#125;

for later processing. Another example is non-deterministic context
switching by yielding &#39;sys_sched&#39;. Suppose there are threads t1 and
t2 at the moment. The system call handler will return

    choices = &#123;
        &#39;t1&#39;: (lambda: switch_to(t1)),
        &#39;t2&#39;: (lambda: switch_to(t2)),
    &#125;

in which switch_to(th) replaces the OS&#39;s current running thread with
th (changes the global &quot;heap&quot; variable). Such deferred execution of
system calls separates the mechanism of non-deterministic choices
from the actual decision makers (e.g., an interpreter or a model
checker). Once the decision is made, the simply call step(choice)
and the OS will execute this choice by

    choices[choice]()

with the application code (generator) being resumed.

This model provides &quot;write&quot; system call to immediately push data to
a hypothetical character device like a tty associated with stdout.
We model a block device (key-value store) that may lose data upon
crash. The model assumes atomicity of each single block write (a
key-value update). However, writes are merely to a volatile buffer
which may non-deterministically lose data upon crash 3]. The &quot;sync&quot;
system call persists buffered writes.

References:

[1] N. Schemenauer, T. Peters, and M. L. Hetland. PEP 255 -
    Simple generators. https://peps.python.org/pep-0255/
[2] J. Yang, C. Sar, and D. Engler. eXplode: a lightweight, general
    system for finding serious storage system errors. OSDI&#39;06.
[3] T. S. Pillai, V. Chidambaram, R. Alagappan, A. Al-Kiswany, A. C.
    Arpaci-Dusseau, and R. H. Arpaci-Dusseau. All file systems are
    not created equal: On the complexity of crafting crash
    consistent applications. OSDI&#39;14.
&quot;&quot;&quot;

def __init__(self, init: Callable):
    &quot;&quot;&quot;Create a new OS instance with pending-to-execute init thread.&quot;&quot;&quot;
    # Operating system states
    self._threads = [Thread(context=init(), heap=Heap())]
    self._current = 0
    self._choices = &#123;init.__name__: lambda: None&#125;
    self._stdout = &#39;&#39;
    self._storage = Storage(persist=&#123;&#125;, buf=&#123;&#125;)

    # Internal states
    self._init = init
    self._trace = []
    self._newfork = set()
</code></pre><h3 id="2-3-System-call-implementation"><a href="#2-3-System-call-implementation" class="headerlink" title="2.3 System call implementation"></a>2.3 System call implementation</h3><h4 id="2-3-1-Process-thread-and-context-switching"><a href="#2-3-1-Process-thread-and-context-switching" class="headerlink" title="2.3.1 Process, thread, and context switching"></a>2.3.1 Process, thread, and context switching</h4><pre><code>@syscall
def sys_spawn(self, func: Callable, *args):
    &quot;&quot;&quot;Spawn a heap-sharing new thread executing func(args).&quot;&quot;&quot;
    def do_spawn():
        self._threads.append(
            Thread(
                context=func(*args),  # func() returns a new generator
                heap=self.current().heap,  # shared heap
            )
        )
    return &#123;&#39;spawn&#39;: (lambda: do_spawn())&#125;

@syscall
def sys_fork(self):
    &quot;&quot;&quot;Create a clone of the current thread with a copied heap.&quot;&quot;&quot;
    if all(not f.frame.f_locals[&#39;fork_child&#39;]
            for f in inspect.stack()
                if f.function == &#39;_step&#39;):  # this is parent; do fork
        # Deep-copying generators causes troubles--they are twined with
        # Python&#39;s runtime state. We use an (inefficient) hack here: replay 
        # the entire trace and override the last fork() to avoid infinite
        # recursion.
        os_clone = OperatingSystem(self._init)
        os_clone.replay(self._trace[:-1])
        os_clone._step(self._trace[-1], fork_child=True)

        # Now os_clone._current is the forked process. Cloned thread just 
        # yields a sys_fork and is pending for fork()&#39;s return value. It
        # is necessary to mark cloned threads (in self._newfork) and send
        # child&#39;s fork() return value when they are scheduled for the
        # first time.
        def do_fork():
            self._threads.append(os_clone.current())
            self._newfork.add((pid := len(self._threads)) - 1)
            return 1000 + pid  # returned pid starts from 1000

        return &#123;&#39;fork&#39;: (lambda: do_fork())&#125;
    else:
        return None  # overridden fork; this value is never used because
                     # os_clone is destroyed immediately after fork()

@syscall
def sys_sched(self):
    &quot;&quot;&quot;Return a non-deterministic context switch to a runnable thread.&quot;&quot;&quot;
    return &#123;
        f&#39;t&#123;i+1&#125;&#39;: (lambda i=i: self._switch_to(i))
            for i, th in enumerate(self._threads)
                if th.context.gi_frame is not None  # thread still alive?
    &#125;
</code></pre><h3 id="2-3-2-Virtual-character-device-byte-stream"><a href="#2-3-2-Virtual-character-device-byte-stream" class="headerlink" title="2.3.2 Virtual character device (byte stream)"></a>2.3.2 Virtual character device (byte stream)</h3><pre><code>@syscall
def sys_choose(self, choices):
    &quot;&quot;&quot;Return a non-deterministic value from choices.&quot;&quot;&quot;
    return &#123;f&#39;choose &#123;c&#125;&#39;: (lambda c=c: c) for c in choices&#125;

@syscall
def sys_write(self, *args):
    &quot;&quot;&quot;Write strings (space separated) to stdout.&quot;&quot;&quot;
    def do_write():
        self._stdout += &#39; &#39;.join(str(arg) for arg in args)
    return &#123;&#39;write&#39;: (lambda: do_write())&#125;
</code></pre><h3 id="2-3-3-Virtual-block-storage-device"><a href="#2-3-3-Virtual-block-storage-device" class="headerlink" title="2.3.3 Virtual block storage device"></a>2.3.3 Virtual block storage device</h3><pre><code>@syscall
def sys_bread(self, key):
    &quot;&quot;&quot;Return the specific key&#39;s associated value in block device.&quot;&quot;&quot;
    storage = self._storage
    return &#123;&#39;bread&#39;: (lambda:
        storage.buf.get(key,  # always try to read from buffer first
            storage.persist.get(key, None)  # and then persistent storage
        )
    )&#125;

@syscall
def sys_bwrite(self, key, value):
    &quot;&quot;&quot;Write (key, value) pair to block device&#39;s buffer.&quot;&quot;&quot;
    def do_bwrite():
        self._storage.buf[key] = value
    return &#123;&#39;bwrite&#39;: (lambda: do_bwrite())&#125;

@syscall
def sys_sync(self):
    &quot;&quot;&quot;Persist all buffered writes.&quot;&quot;&quot;
    def do_sync():
        store = self._storage
        self._storage = Storage(
            persist=store.persist | store.buf,  # write back
            buf=&#123;&#125;
        )
    return &#123;&#39;sync&#39;: (lambda: do_sync())&#125;

@syscall
def sys_crash(self):
    &quot;&quot;&quot;Simulate a system crash that non-deterministically persists
    outstanding writes in the buffer.
    &quot;&quot;&quot;
    persist = self._storage.persist
    btrace = self._storage.buf.items()  # block trace

    crash_sites = (
        lambda subset=subset:
            setattr(self, &#39;_storage&#39;,
                Storage(  # persist only writes in the subset
                    persist=persist | dict(compress(btrace, subset)),
                    buf=&#123;&#125;
                )
            ) for subset in  # Mosaic allows persisting any subset of
                product(     # pending blocks in the buffer
                    *([(0, 1)] * len(btrace))
                )
    )
    return dict(enumerate(crash_sites))
</code></pre><h3 id="2-4-Operating-system-as-a-state-machine"><a href="#2-4-Operating-system-as-a-state-machine" class="headerlink" title="2.4 Operating system as a state machine"></a>2.4 Operating system as a state machine</h3><pre><code>def replay(self, trace: list) -&gt; dict:
    &quot;&quot;&quot;Replay an execution trace and return the resulting state.&quot;&quot;&quot;
    for choice in trace:
        self._step(choice)
    return self.state_dump()

def _step(self, choice, fork_child=False):
    self._switch_to(self._current)
    self._trace.append(choice)  # keep all choices for replay-based fork()
    action = self._choices[choice]  # return value of sys_xxx: a lambda
    res = action()

    try:  # Execute current thread for one step
        func, args = self.current().context.send(res)
        assert func in SYSCALLS
        self._choices = getattr(self, func)(*args)
    except StopIteration:  # ... and thread terminates
        self._choices = self.sys_sched()

    # At this point, the operating system&#39;s state is
    #   (self._threads, self._current, self._stdout, self._storage)
    # and outgoing transitions are saved in self._choices.
</code></pre><h3 id="2-5-Misc-and-helper-functions"><a href="#2-5-Misc-and-helper-functions" class="headerlink" title="2.5 Misc and helper functions"></a>2.5 Misc and helper functions</h3><pre><code>def state_dump(self) -&gt; dict:
    &quot;&quot;&quot;Create a serializable Mosaic state dump with hash code.&quot;&quot;&quot;
    heaps = &#123;&#125;
    for th in self._threads:
        if (i := id(th.heap)) not in heaps:  # unique heaps
            heaps[i] = len(heaps) + 1

    os_state = &#123;
        &#39;current&#39;: self._current,
        &#39;choices&#39;: sorted(list(self._choices.keys())),
        &#39;contexts&#39;: [
            &#123;
                &#39;heap&#39;: heaps[id(th.heap)],  # the unique heap id
                &#39;pc&#39;: th.context.gi_frame.f_lineno,
                &#39;locals&#39;: th.context.gi_frame.f_locals,
            &#125; if th.context.gi_frame is not None else None
                for th in self._threads
        ],
        &#39;heaps&#39;: &#123;
            heaps[id(th.heap)]: th.heap.__dict__
                for th in self._threads
        &#125;,
        &#39;stdout&#39;: self._stdout,
        &#39;store_persist&#39;: self._storage.persist,
        &#39;store_buffer&#39;: self._storage.buf,
    &#125;

    h = hash(json.dumps(os_state, sort_keys=True)) + 2**63
    return (copy.deepcopy(os_state)  # freeze the runtime state
            | dict(hashcode=f&#39;&#123;h:016x&#125;&#39;))

def current(self) -&gt; Thread:
    &quot;&quot;&quot;Return the current running thread object.&quot;&quot;&quot;
    return self._threads[self._current]

def _switch_to(self, tid: int):
    self._current = tid
    globals()[&#39;os&#39;] = self
    globals()[&#39;heap&#39;] = self.current().heap
    if tid in self._newfork:
        self._newfork.remove(tid)  # tricky: forked process must receive 0
        return 0                   # to indicate a child
</code></pre><h2 id="3-The-Mosaic-runtime"><a href="#3-The-Mosaic-runtime" class="headerlink" title="3. The Mosaic runtime"></a>3. The Mosaic runtime</h2><p>class Mosaic:<br>    “””The operating system interpreter and model checker.</p>
<pre><code>The operating system model is a state transition system: os.replay()
maps any trace to a state (with its outgoing transitions). Based
on this model, two state space explorers are implemented:

- run:   Choose outgoing transitions uniformly at random, yielding a
         single execution trace.
- check: Exhaustively explore all reachable states by a breadth-
         first search. Duplicated states are not visited twice.

Both explorers produce the visited portion of the state space as a
serializable object containing:

- source:   The application source code
- vertices: A list of operating system state dumps. The first vertex
            in the list is the initial state. Each vertex has a
            unique &quot;hashcode&quot; id.
- edges:    A list of 3-tuples: (source, target, label) denoting an 
            explored source --[label]-&gt; target edge. Both source and
            target are state hashcode ids.
&quot;&quot;&quot;
</code></pre><h3 id="3-1-Model-interpreter-and-checker"><a href="#3-1-Model-interpreter-and-checker" class="headerlink" title="3.1 Model interpreter and checker"></a>3.1 Model interpreter and checker</h3><pre><code>def run(self) -&gt; dict:
    &quot;&quot;&quot;Interpret the model with non-deterministic choices.&quot;&quot;&quot;
    os = OperatingSystem(self.entry)
    V, E = [os.state_dump() | dict(depth=0)], []

    while (choices := V[-1][&#39;choices&#39;]):
        choice = random.choice(choices)  # uniformly at random
        V.append(os.replay([choice]) | dict(depth=len(V)))
        E.append((V[-2][&#39;hashcode&#39;], V[-1][&#39;hashcode&#39;], choice))

    return dict(source=self.src, vertices=V, edges=E)

def check(self) -&gt; dict:
    &quot;&quot;&quot;Exhaustively explore the state space.&quot;&quot;&quot;
    class State:
        entry = self.entry

        def __init__(self, trace):
            self.trace = trace
            self.state = OperatingSystem(State.entry).replay(trace)
            self.state |= dict(depth=0)
            self.hashcode = self.state[&#39;hashcode&#39;]

        def extend(self, c):
            st = State(self.trace + (c,))
            st.state = st.state | dict(depth=self.state[&#39;depth&#39;] + 1)
            return st

    st0 = State(tuple())  # initial state of empty trace
    queued, V, E = [st0], &#123;st0.hashcode: st0.state&#125;, []

    while queued:
        st = queued.pop(0)
        for choice in st.state[&#39;choices&#39;]:
            st1 = st.extend(choice)
            if st1.hashcode not in V:  # found an unexplored state
                V[st1.hashcode] = st1.state
                queued.append(st1)
            E.append((st.hashcode, st1.hashcode, choice))

    return dict(
        source=self.src,
        vertices=sorted(V.values(), key=lambda st: st[&#39;depth&#39;]),
        edges=E
    )
</code></pre><h3 id="3-1-Source-code-parsing-and-rewriting"><a href="#3-1-Source-code-parsing-and-rewriting" class="headerlink" title="3.1 Source code parsing and rewriting"></a>3.1 Source code parsing and rewriting</h3><pre><code>class Transformer(ast.NodeTransformer):
    def visit_Call(self, node):
        # Rewrite system calls as yields
        if (isinstance(node.func, ast.Name) and
                node.func.id in SYSCALLS):  # rewrite system calls
            return ast.Yield(ast.Tuple(     #   -&gt; yield (&#39;sys_xxx&#39;, args)
                elts=[
                    ast.Constant(value=node.func.id),
                    ast.Tuple(elts=node.args),
                ]
            ))
        else:
            return node

def __init__(self, src: str):
    tree = ast.parse(src)
    hacked_ast = self.Transformer().visit(tree)
    hacked_src = ast.unparse(hacked_ast)

    context = &#123;&#125;
    exec(hacked_src, globals(), context)
    globals().update(context)

    self.src = src
    self.entry = context[&#39;main&#39;]  # must have a main()
</code></pre><h2 id="4-Utilities"><a href="#4-Utilities" class="headerlink" title="4. Utilities"></a>4. Utilities</h2><p>if <strong>name</strong> == ‘<strong>main</strong>‘:<br>    parser = argparse.ArgumentParser(<br>        description=’The modeled operating system and state explorer.’<br>    )<br>    parser.add_argument(<br>        ‘source’,<br>        help=’application code (.py) to be checked; must have a main()’<br>    )<br>    parser.add_argument(‘-r’, ‘—run’, action=’store_true’)<br>    parser.add_argument(‘-c’, ‘—check’, action=’store_true’)<br>    args = parser.parse_args()</p>
<pre><code>src = Path(args.source).read_text()
mosaic = Mosaic(src)
if args.check:
    explored = mosaic.check()
else:
    explored = mosaic.run()  # run is the default option

# Serialize the explored states and write to stdout. This encourages piping
# the results to another tool following the UNIX philosophy. Examples:
#
#   mosaic --run foo.py | grep stdout | tail -n 1  # quick and dirty check
#   mosaic --check bar.py | fx  # or any other interactive visualizer
#
print(json.dumps(explored, ensure_ascii=False, indent=2))
</code></pre><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- hello.py</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>def hello(s):<br>    return f’Hello, {s}\n’</p>
<p>def main():<br>    sys_write(hello(‘OS’))<br>    sys_write(hello(‘World’))<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">![img](../img/image-11-1024x408.png)运行结果</span><br><span class="line"></span><br><span class="line">输出的json内容如下：</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>{<br>  “source”: “def hello(s):\n    return f’Hello, {s}\n’\n\ndef main():\n    sys_write(hello(‘OS’))\n    sys_write(hello(‘World’))\n”,<br>  “vertices”: [<br>    {<br>      “current”: 0,<br>      “choices”: [<br>        “main”<br>      ],<br>      “contexts”: [<br>        {<br>          “heap”: 1,<br>          “pc”: 4,<br>          “locals”: {}<br>        }<br>      ],<br>      “heaps”: {<br>        “1”: {}<br>      },<br>      “stdout”: “”,<br>      “store_persist”: {},<br>      “store_buffer”: {},<br>      “hashcode”: “406bec4fbd4b5d4f”,<br>      “depth”: 0<br>    },<br>    {<br>      “current”: 0,<br>      “choices”: [<br>        “write”<br>      ],<br>      “contexts”: [<br>        {<br>          “heap”: 1,<br>          “pc”: 5,<br>          “locals”: {}<br>        }<br>      ],<br>      “heaps”: {<br>        “1”: {}<br>      },<br>      “stdout”: “”,<br>      “store_persist”: {},<br>      “store_buffer”: {},<br>      “hashcode”: “9e2e4498c1ff0567”,<br>      “depth”: 1<br>    },<br>    {<br>      “current”: 0,<br>      “choices”: [<br>        “write”<br>      ],<br>      “contexts”: [<br>        {<br>          “heap”: 1,<br>          “pc”: 6,<br>          “locals”: {}<br>        }<br>      ],<br>      “heaps”: {<br>        “1”: {}<br>      },<br>      “stdout”: “Hello, OS\n”,<br>      “store_persist”: {},<br>      “store_buffer”: {},<br>      “hashcode”: “b2475d0bbff9b748”,<br>      “depth”: 2<br>    },<br>    {<br>      “current”: 0,<br>      “choices”: [],<br>      “contexts”: [<br>        null<br>      ],<br>      “heaps”: {<br>        “1”: {}<br>      },<br>      “stdout”: “Hello, OS\nHello, World\n”,<br>      “store_persist”: {},<br>      “store_buffer”: {},<br>      “hashcode”: “27f2e79cbd5a9d60”,<br>      “depth”: 3<br>    }<br>  ],<br>  “edges”: [<br>    [<br>      “406bec4fbd4b5d4f”,<br>      “9e2e4498c1ff0567”,<br>      “main”<br>    ],<br>    [<br>      “9e2e4498c1ff0567”,<br>      “b2475d0bbff9b748”,<br>      “write”<br>    ],<br>    [<br>      “b2475d0bbff9b748”,<br>      “27f2e79cbd5a9d60”,<br>      “write”<br>    ]<br>  ]<br>}<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">![img](../img/image-12-1024x592.png)可视化结果</span><br><span class="line"></span><br><span class="line">![img](../img/image-13-1024x655.png)多线程程序最小值</span><br><span class="line"></span><br><span class="line"># 并发1_多处理器编程_2023.3.7</span><br><span class="line"></span><br><span class="line">## 多处理器编程入门</span><br><span class="line"></span><br><span class="line">操作系统作为 “状态机的管理者”，引入了共享的状态</span><br><span class="line"></span><br><span class="line">- 带来了并发</span><br><span class="line">- (操作系统是最早的并发程序)</span><br><span class="line"></span><br><span class="line">对hello.py，不同时间运行结果不一致</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>def Tprint(name):<br>  sys_write(f’{name}’)</p>
<p>def main():<br>  for name in ‘AB’:<br>    sys_spawn(Tprint, name)<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">![img](../img/image-145.png)运行结果</span><br><span class="line"></span><br><span class="line">### 多线程共享内存并发</span><br><span class="line"></span><br><span class="line">线程：共享内存的执行流</span><br><span class="line"></span><br><span class="line">- 执行流拥有独立的堆栈/寄存器</span><br><span class="line"></span><br><span class="line">简化的线程 API (thread.h)</span><br><span class="line"></span><br><span class="line">- ```</span><br><span class="line">  spawn(fn)</span><br></pre></td></tr></table></figure></p>
<ul>
<li><p>创建一个入口函数是 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fn</span><br></pre></td></tr></table></figure>
<p> 的线程，并立即开始执行</p>
<ul>
<li><code>void fn(int tid) &#123; ... &#125;</code></li>
<li>参数 <code>tid</code> 从 1 开始编号</li>
</ul>
</li>
<li><p>行为：<code>sys_spawn(fn, tid)</code></p>
</li>
</ul>
<ul>
<li>```<br>join()<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  - 等待所有运行线程的返回 (也可以不调用)</span><br><span class="line">  - 行为：`while (done != T) sys_sched()`</span><br><span class="line"></span><br><span class="line">hello.c</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="include-“thread-h”"><a href="#include-“thread-h”" class="headerlink" title="include “thread.h”"></a>include “thread.h”</h1></li>
</ul>
<p>void Thello(int id) {<br>  while (1) {<br>    printf(“%c”, “_ABCDEFGHIJKLMNOPQRSTUVWXYZ”[id]);<br>  }<br>}</p>
<p>int main() {<br>  for (int i = 0; i &lt; 10; i++) {<br>    create(Thello);<br>  }<br>}<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">thread.h</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h1 id="include-4"><a href="#include-4" class="headerlink" title="include "></a>include <stdlib.h></h1><h1 id="include-5"><a href="#include-5" class="headerlink" title="include "></a>include <stdio.h></h1><h1 id="include-6"><a href="#include-6" class="headerlink" title="include "></a>include <string.h></h1><h1 id="include-7"><a href="#include-7" class="headerlink" title="include "></a>include <stdatomic.h></h1><h1 id="include-8"><a href="#include-8" class="headerlink" title="include "></a>include <assert.h></h1><h1 id="include-9"><a href="#include-9" class="headerlink" title="include "></a>include <unistd.h></h1><h1 id="include-10"><a href="#include-10" class="headerlink" title="include "></a>include <pthread.h></h1><h1 id="define-NTHREAD-64"><a href="#define-NTHREAD-64" class="headerlink" title="define NTHREAD 64"></a>define NTHREAD 64</h1><p>enum { T_FREE = 0, T_LIVE, T_DEAD, };<br>struct thread {<br>  int id, status;<br>  pthread_t thread;<br>  void (*entry)(int);<br>};</p>
<p>struct thread tpool[NTHREAD], *tptr = tpool;</p>
<p>void <em>wrapper(void </em>arg) {<br>  struct thread <em>thread = (struct thread </em>)arg;<br>  thread-&gt;entry(thread-&gt;id);<br>  return NULL;<br>}</p>
<p>void create(void <em>fn) {<br>  assert(tptr - tpool &lt; NTHREAD);
  </em>tptr = (struct thread) {<br>    .id = tptr - tpool + 1,<br>    .status = T_LIVE,<br>    .entry = fn,<br>  };<br>  pthread_create(&amp;(tptr-&gt;thread), NULL, wrapper, tptr);<br>  ++tptr;<br>}</p>
<p>void join() {<br>  for (int i = 0; i &lt; NTHREAD; i++) {<br>    struct thread *t = &amp;tpool[i];<br>    if (t-&gt;status == T_LIVE) {<br>      pthread_join(t-&gt;thread, NULL);<br>      t-&gt;status = T_DEAD;<br>    }<br>  }<br>}</p>
<p><strong>attribute</strong>((destructor)) void cleanup() {<br>  join();<br>}<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">![img](../img/image-146-1024x628.png)运行结果</span><br><span class="line"></span><br><span class="line">查看cpu发现，cpu占用达到800%，说明可以使用多处理器。</span><br><span class="line"></span><br><span class="line">![img](../img/image-147-1024x261.png)800%</span><br><span class="line"></span><br><span class="line">### 多线程共享内存并发：入门</span><br><span class="line"></span><br><span class="line">多处理器编程：一个 API 搞定</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h1 id="include-“thread-h”-1"><a href="#include-“thread-h”-1" class="headerlink" title="include “thread.h”"></a>include “thread.h”</h1><p>void Ta() { while (1) { printf(“a”); } }<br>void Tb() { while (1) { printf(“b”); } }</p>
<p>int main() {<br>  create(Ta);<br>  create(Tb);<br>}<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 这个程序可以利用系统中的多处理器</span><br><span class="line">  - 操作系统会自动把线程放置在不同的处理器上</span><br><span class="line">  - CPU 使用率超过了 100%</span><br><span class="line"></span><br><span class="line">### 问出更多的问题</span><br><span class="line"></span><br><span class="line">`Ta` 和 `Tb` 真的共享内存吗？</span><br><span class="line"></span><br><span class="line">- 如何证明/否证这件事？</span><br><span class="line"></span><br><span class="line">如何证明线程具有独立堆栈 (以及确定堆栈的范围)？</span><br><span class="line"></span><br><span class="line">- 输出混乱，应该如何处理？</span><br><span class="line"></span><br><span class="line">更多的 “好问题” 和解决</span><br><span class="line"></span><br><span class="line">- 创建线程使用的是哪个系统调用？</span><br><span class="line">- 能不能用 gdb 调试？</span><br><span class="line">  - 基本原则：有需求，就能做到 ([RTFM](https://sourceware.org/gdb/onlinedocs/gdb/Threads.html))</span><br><span class="line"></span><br><span class="line">stack-probe.c</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h1 id="include-“thread-h”-2"><a href="#include-“thread-h”-2" class="headerlink" title="include “thread.h”"></a>include “thread.h”</h1><h1 id="include-11"><a href="#include-11" class="headerlink" title="include "></a>include <stdint.h></h1><p>void <em> volatile low[64];<br>void </em> volatile high[64];</p>
<p>void update_range(int T, void *ptr) {<br>    if (ptr &lt; low[T]) low[T] = ptr;<br>    if (ptr &gt; high[T]) high[T] = ptr;<br>}</p>
<p>void probe(int T, int n) {<br>  update_range(T, &amp;n);<br>  long sz = (uintptr_t)high[T] - (uintptr_t)low[T];<br>  if (sz % 1024 &lt; 32) {<br>    printf(“Stack(T%d) &gt;= %ld KB\n”, T, sz / 1024);<br>  }<br>  probe(T, n + 1);  // Infinite recursion<br>}</p>
<p>void Tprobe(int T) {<br>  low[T] = (void <em>)-1;<br>  high[T] = (void </em>)0;<br>  update_range(T, &amp;T);<br>  probe(T, 0);<br>}</p>
<p>int main() {<br>  setbuf(stdout, NULL);<br>  for (int i = 0; i &lt; 4; i++) {<br>    create(Tprobe);<br>  }<br>}<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">![img](../img/image-148.png)结果</span><br><span class="line"></span><br><span class="line">最多8192kb。排序后最大可以看到的是8177。</span><br><span class="line"></span><br><span class="line">![img](../img/image-149.png)排序后结果</span><br><span class="line"></span><br><span class="line">### `thread.h` 背后：POSIX Threads</span><br><span class="line"></span><br><span class="line">想进一步配置线程？</span><br><span class="line"></span><br><span class="line">- 设置更大的线程栈</span><br><span class="line">- 设置 detach 运行 (不在进程结束后被杀死，也不能 join)</span><br><span class="line">- ……</span><br><span class="line"></span><br><span class="line">POSIX 为我们提供了线程库 (pthreads)</span><br><span class="line"></span><br><span class="line">- `man 7 pthreads`</span><br><span class="line">- 练习：改写 thread.h，使得线程拥有更大的栈</span><br><span class="line">  - 可以用 stack probe 的程序验证</span><br><span class="line"></span><br><span class="line">## 放弃 (1)：原子性</span><br><span class="line"></span><br><span class="line">### 状态机的隐含假设</span><br><span class="line"></span><br><span class="line">“世界上只有一个状态机”</span><br><span class="line"></span><br><span class="line">- 没有其他任何人能 “干涉” 程序的状态</span><br><span class="line">- 推论：对变量的 load 一定返回本线程最后一次 store 的值</span><br><span class="line">  - 这也是编译优化的基本假设</span><br><span class="line"></span><br><span class="line">但共享内存推翻了这个假设</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>int Tworker() {<br>  printf(“%d\n”, x);  // Global x<br>  printf(“%d\n”, x);<br>}<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 其他线程随时可以修改 </span><br><span class="line"></span><br></pre></td></tr></table></figure><br>  x<br>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  - 导致两次可能读到不同的 `x`</span><br><span class="line"></span><br><span class="line">潘多拉的魔盒已经打开……</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>unsigned int balance = 100;</p>
<p>int Talipay_withdraw(int amt) {<br>  if (balance &gt;= amt) {<br>    balance -= amt;<br>    return SUCCESS;<br>  } else {<br>    return FAIL;<br>  }<br>}<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">两个线程并发支付 ¥100 会发生什么 (代码演示)</span><br><span class="line"></span><br><span class="line">- 账户里会多出用不完的钱！</span><br><span class="line">- Bug/漏洞不跟你开玩笑：Mt. Gox Hack 损失 650,000 BTC</span><br><span class="line">  - 时值 ~$28,000,000,000</span><br><span class="line"></span><br><span class="line">alipay.c</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h1 id="include-“thread-h”-3"><a href="#include-“thread-h”-3" class="headerlink" title="include “thread.h”"></a>include “thread.h”</h1><p>unsigned long balance = 100;</p>
<p>void Alipay_withdraw(int amt) {<br>  if (balance &gt;= amt) {<br>    usleep(1);  // Unexpected delays<br>    balance -= amt;<br>  }<br>}</p>
<p>void Talipay(int id) {<br>  Alipay_withdraw(100);<br>}</p>
<p>int main() {<br>  create(Talipay);<br>  create(Talipay);<br>  join();<br>  printf(“balance = %lu\n”, balance);<br>}<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">![img](../img/image-150.png)运行结果</span><br><span class="line"></span><br><span class="line">### 例子：Diablo I (1996)</span><br><span class="line"></span><br><span class="line">在捡起要复制物品的瞬间拿起 1 块钱</span><br><span class="line"></span><br><span class="line">- 1 块钱会被 “覆盖” 成捡起的物品</span><br><span class="line"></span><br><span class="line">&lt;video controls=&quot;&quot; src=&quot;https://jyywiki.cn/pages/OS/img/diablo-item-clone.mp4&quot;&gt;&lt;/video&gt;</span><br><span class="line"></span><br><span class="line">### 例子：求和</span><br><span class="line"></span><br><span class="line">分两个线程，计算 1+1+1+…+11+1+1+…+1 (共计 2*n* 个 1)</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h1 id="define-N-100000000"><a href="#define-N-100000000" class="headerlink" title="define N 100000000"></a>define N 100000000</h1><p>long sum = 0;</p>
<p>void Tsum() { for (int i = 0; i &lt; N; i++) sum++; }</p>
<p>int main() {<br>  create(Tsum);<br>  create(Tsum);<br>  join();<br>  printf(“sum = %ld\n”, sum);<br>}<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">可能的结果</span><br><span class="line"></span><br><span class="line">- 119790390, 99872322 (结果可以比 `N` 还要小), ...</span><br><span class="line">- 直接使用汇编指令也不行</span><br><span class="line"></span><br><span class="line">![img](../img/image-151.png)结果</span><br><span class="line"></span><br><span class="line">### 指令/代码执行原子性假设</span><br><span class="line"></span><br><span class="line">&gt; “处理器一次执行一条指令” 的基本假设在今天的计算机系统上不再成立 (我们的模型作出了简化的假设)。</span><br><span class="line"></span><br><span class="line">单处理器多线程</span><br><span class="line"></span><br><span class="line">- 线程在运行时可能被中断，切换到另一个线程执行</span><br><span class="line"></span><br><span class="line">多处理器多线程</span><br><span class="line"></span><br><span class="line">- 线程根本就是并行执行的</span><br><span class="line"></span><br><span class="line">(历史) 1960s，大家争先在共享内存上实现原子性 (互斥)</span><br><span class="line"></span><br><span class="line">- 但几乎所有的实现都是错的，直到 [Dekker&#x27;s Algorithm](https://en.wikipedia.org/wiki/Dekker&#x27;s_algorithm)，还只能保证两个线程的互斥</span><br><span class="line"></span><br><span class="line">### 放弃原子性假设的后果</span><br><span class="line"></span><br><span class="line">`printf` 还能在多线程程序里调用吗？</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>void thread1() { while (1) { printf(“a”); } }<br>void thread2() { while (1) { printf(“b”); } }<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">我们都知道 printf 是有缓冲区的 (为什么？)</span><br><span class="line"></span><br><span class="line">- 如果执行 `buf[pos++] = ch` (`pos` 共享) 不就 💥 了吗？</span><br><span class="line"></span><br><span class="line">## 放弃 (2)：执行顺序</span><br><span class="line"></span><br><span class="line">分两个线程，计算 1+1+1+…+11+1+1+…+1 (共计 2*n* 个 1)</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h1 id="define-N-100000000-1"><a href="#define-N-100000000-1" class="headerlink" title="define N 100000000"></a>define N 100000000</h1><p>long sum = 0;</p>
<p>void Tsum() { for (int i = 0; i &lt; N; i++) sum++; }</p>
<p>int main() {<br>  create(Tsum);<br>  create(Tsum);<br>  join();<br>  printf(“sum = %ld\n”, sum);<br>}<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">如果添加编译优化？</span><br><span class="line"></span><br><span class="line">- `-O1`: 100000000 😱😱</span><br><span class="line">- `-O2`: 200000000 😱😱😱</span><br><span class="line"></span><br><span class="line">![img](../img/image-152.png)结果</span><br><span class="line"></span><br><span class="line">**编译器仅对顺序执行的程序负责！**</span><br><span class="line"></span><br><span class="line">&gt; 编译器对内存访问 “eventually consistent” 的处理导致共享内存作为线程同步工具的失效。</span><br><span class="line"></span><br><span class="line">刚才的例子</span><br><span class="line"></span><br><span class="line">- `-O1`: `R[eax] = sum; R[eax] += N; sum = R[eax]`</span><br><span class="line">- `-O2`: `sum += N;`</span><br><span class="line">- (你的编译器也许是不同的结果)</span><br><span class="line"></span><br><span class="line">另一个例子</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>while (!done);<br>// would be optimized to<br>if (!done) while (1);<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 保证执行顺序</span><br><span class="line"></span><br><span class="line">回忆 “编译正确性”</span><br><span class="line"></span><br><span class="line">- C 状态和汇编状态机的 “可观测行为等价”</span><br><span class="line"></span><br><span class="line">- 方法 1：插入 “不可优化” 代码</span><br><span class="line"></span><br><span class="line">  - ```</span><br><span class="line">    asm volatile (&quot;&quot; ::: &quot;memory&quot;);</span><br></pre></td></tr></table></figure></p>
<pre><code>- “Clobbers memory”
</code></pre><ul>
<li><p>方法 2：标记变量 load/store 为不可优化</p>
<ul>
<li>使用 <code>volatile</code> 变量</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">extern int volatile done;</span><br><span class="line"></span><br><span class="line">while (!done) ;</span><br></pre></td></tr></table></figure>
<h2 id="放弃-3-：处理器间的可见性"><a href="#放弃-3-：处理器间的可见性" class="headerlink" title="放弃 (3)：处理器间的可见性"></a>放弃 (3)：处理器间的可见性</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">int x = 0, y = 0;</span><br><span class="line"></span><br><span class="line">void T1() &#123;</span><br><span class="line">  x = 1;  // Store(x)</span><br><span class="line">  __sync_synchronize();</span><br><span class="line">  printf(&quot;%d&quot;, y);  // Load(y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void T2() &#123;</span><br><span class="line">  y = 1;  // Store(y)</span><br><span class="line">  __sync_synchronize();</span><br><span class="line">  printf(&quot;%d&quot;, x); // Load(x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>遍历模型告诉我们：01, 10, 11</p>
<ul>
<li>机器永远是对的</li>
<li>Model checker 的结果和实际的结果不同 → 假设错了</li>
</ul>
<p>store-load.c</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;thread.h&quot;</span><br><span class="line">#include &lt;stdatomic.h&gt;</span><br><span class="line"></span><br><span class="line">int x = 0, y = 0;</span><br><span class="line"></span><br><span class="line">atomic_int flag;</span><br><span class="line">#define FLAG atomic_load(&amp;flag)</span><br><span class="line">#define FLAG_XOR(val) atomic_fetch_xor(&amp;flag, val)</span><br><span class="line">#define WAIT_FOR(cond) while (!(cond)) ;</span><br><span class="line"></span><br><span class="line"> __attribute__((noinline))</span><br><span class="line">void write_x_read_y() &#123;</span><br><span class="line">  int y_val;</span><br><span class="line">  asm volatile(</span><br><span class="line">    &quot;movl $1, %0;&quot; // x = 1</span><br><span class="line">    &quot;movl %2, %1;&quot; // y_val = y</span><br><span class="line">    : &quot;=m&quot;(x), &quot;=r&quot;(y_val) : &quot;m&quot;(y)</span><br><span class="line">  );</span><br><span class="line">  printf(&quot;%d &quot;, y_val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> __attribute__((noinline))</span><br><span class="line">void write_y_read_x() &#123;</span><br><span class="line">  int x_val;</span><br><span class="line">  asm volatile(</span><br><span class="line">    &quot;movl $1, %0;&quot; // y = 1</span><br><span class="line">    &quot;movl %2, %1;&quot; // x_val = x</span><br><span class="line">    : &quot;=m&quot;(y), &quot;=r&quot;(x_val) : &quot;m&quot;(x)</span><br><span class="line">  );</span><br><span class="line">  printf(&quot;%d &quot;, x_val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void T1(int id) &#123;</span><br><span class="line">  while (1) &#123;</span><br><span class="line">    WAIT_FOR((FLAG &amp; 1));</span><br><span class="line">    write_x_read_y();</span><br><span class="line">    FLAG_XOR(1);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void T2() &#123;</span><br><span class="line">  while (1) &#123;</span><br><span class="line">    WAIT_FOR((FLAG &amp; 2));</span><br><span class="line">    write_y_read_x();</span><br><span class="line">    FLAG_XOR(2);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Tsync() &#123;</span><br><span class="line">  while (1) &#123;</span><br><span class="line">    x = y = 0;</span><br><span class="line">    __sync_synchronize(); // full barrier</span><br><span class="line">    usleep(1);            // + delay</span><br><span class="line">    assert(FLAG == 0);</span><br><span class="line">    FLAG_XOR(3);</span><br><span class="line">    // T1 and T2 clear 0/1-bit, respectively</span><br><span class="line">    WAIT_FOR(FLAG == 0);</span><br><span class="line">    printf(&quot;\n&quot;); fflush(stdout);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">  create(T1);</span><br><span class="line">  create(T2);</span><br><span class="line">  create(Tsync);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然而实际输出如下，11出现得极少。<br>1 0<br>0 1<br>0 0</p>
<p>解释：赋值操作不是原子性，load操作往往比store快。使得两边同时load到0。</p>
<h3 id="现代处理器也是-动态-编译器！"><a href="#现代处理器也是-动态-编译器！" class="headerlink" title="现代处理器也是 (动态) 编译器！"></a>现代处理器也是 (动态) 编译器！</h3><p>错误 (简化) 的假设</p>
<ul>
<li>一个 CPU 执行一条指令到达下一状态</li>
</ul>
<p>实际的实现</p>
<ul>
<li><p>电路将连续的指令 “编译” 成更小的 </p>
<p>μ</p>
<p>ops</p>
<ul>
<li>RF[9] = load(RF[7] + 400)</li>
<li>store(RF[12], RF[13])</li>
<li>RF[3] = RF[4] + RF[5]</li>
</ul>
</li>
</ul>
<p>在任何时刻，处理器都维护一个 <em>μ</em>op 的 “池子”</p>
<ul>
<li>与编译器一样，做 “顺序执行” 假设：没有其他处理器 “干扰”</li>
<li>每一周期执行尽可能多的 <em>μ</em>op - 多路发射、乱序执行、按序提交</li>
</ul>
<blockquote>
<p>满足单处理器 eventual memory consistency 的执行，在多处理器系统上可能无法序列化！</p>
</blockquote>
<p><img src="../img/image-154-1024x240.png" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">     # &lt;-----------+</span><br><span class="line">movl $1, (x)   #   |</span><br><span class="line">movl (y), %eax # --+</span><br></pre></td></tr></table></figure>
<ul>
<li>在多处理器上的表现<ul>
<li>两个处理器分别看到y=0和<em>x</em>=0</li>
</ul>
</li>
</ul>
<h3 id="宽松内存模型-Relaxed-Weak-Memory-Model"><a href="#宽松内存模型-Relaxed-Weak-Memory-Model" class="headerlink" title="宽松内存模型 (Relaxed/Weak Memory Model)"></a>宽松内存模型 (Relaxed/Weak Memory Model)</h3><blockquote>
<p>宽松内存模型的目的是使单处理器的执行更高效。</p>
</blockquote>
<p>x86 已经是市面上能买到的 “最强” 的内存模型了 😂</p>
<ul>
<li>这也是 Intel 自己给自己加的包袱</li>
<li>看看 <a target="_blank" rel="noopener" href="https://research.swtch.com/mem-weak@2x.png">ARM/RISC-V</a> 吧，根本就是个分布式系统</li>
</ul>
<p><img src="../img/image-155.png" alt="img">(x86-TSO in <a target="_blank" rel="noopener" href="https://research.swtch.com/hwmm">Hardware memory models</a> by Russ Cox)</p>
<p><img src="../img/image-156.png" alt="img"><a target="_blank" rel="noopener" href="https://research.swtch.com/mem-weak@2x.png">ARM/RISC-V</a></p>
<p>so，老老实实地用lock和unlock。</p>
<h1 id="并发2-并发控制基础-2023-3-9"><a href="#并发2-并发控制基础-2023-3-9" class="headerlink" title="并发2_并发控制基础_2023.3.9"></a>并发2_并发控制基础_2023.3.9</h1><h2 id="互斥问题"><a href="#互斥问题" class="headerlink" title="互斥问题"></a>互斥问题</h2><h3 id="并发编程：从入门到放弃"><a href="#并发编程：从入门到放弃" class="headerlink" title="并发编程：从入门到放弃"></a>并发编程：从入门到放弃</h3><p>人类是 sequential creature</p>
<ul>
<li>编译优化 + weak memory model 导致难以理解的并发执行</li>
<li>有多难理解呢？<ul>
<li><a target="_blank" rel="noopener" href="https://epubs.siam.org/doi/10.1137/S0097539794279614">Verifying sequential consistency 是 NP-完全问题</a></li>
</ul>
</li>
</ul>
<p>人类是 (不轻言放弃的) sequential creature</p>
<ul>
<li>有问题，就会试着去解决</li>
<li>手段：“回退到” 顺序执行<ul>
<li>标记若干块代码，使得这些代码一定能按某个顺序执行</li>
<li>例如，我们可以安全地在块里记录执行的顺序</li>
</ul>
</li>
</ul>
<h3 id="回退到顺序执行：互斥"><a href="#回退到顺序执行：互斥" class="headerlink" title="回退到顺序执行：互斥"></a>回退到顺序执行：互斥</h3><p>插入 “神秘代码”，使得所有其他 “神秘代码” 都不能并发</p>
<ul>
<li>由 “神秘代码” 领导不会并发的代码 (例如 pure functions) 执行</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void Tsum() &#123;</span><br><span class="line">  stop_the_world();</span><br><span class="line">  // 临界区 critical section</span><br><span class="line">  sum++;</span><br><span class="line">  resume_the_world();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Stop the world 真的是可能的</p>
<ul>
<li>Java 有 “stop the world GC”</li>
<li>单个处理器可以关闭中断</li>
<li>多个处理器也可以发送核间中断</li>
</ul>
<h3 id="失败的尝试"><a href="#失败的尝试" class="headerlink" title="失败的尝试"></a>失败的尝试</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">int locked = UNLOCK;</span><br><span class="line"></span><br><span class="line">void critical_section() &#123;</span><br><span class="line">retry:</span><br><span class="line">  if (locked != UNLOCK) &#123;</span><br><span class="line">    goto retry;</span><br><span class="line">  &#125;</span><br><span class="line">  locked = LOCK;</span><br><span class="line"></span><br><span class="line">  // critical section</span><br><span class="line"></span><br><span class="line">  locked = UNLOCK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>和 “山寨支付宝” 完全一样的错误</p>
<ul>
<li>并发程序不能保证 load + store 的原子性</li>
</ul>
<p><img src="../img/image-163.png" alt="img">出错</p>
<h3 id="更严肃地尝试：确定假设、设计算法"><a href="#更严肃地尝试：确定假设、设计算法" class="headerlink" title="更严肃地尝试：确定假设、设计算法"></a>更严肃地尝试：确定假设、设计算法</h3><p>假设：内存的读/写可以保证顺序、原子完成</p>
<ul>
<li><p>```<br>val = atomic_load(ptr)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  - 对应往某个地方 “贴一张纸条” (必须闭眼盲贴)</span><br><span class="line">  - 贴完一瞬间就可能被别人覆盖</span><br><span class="line"></span><br><span class="line">- ```</span><br><span class="line">  atomic_store(ptr, val)</span><br></pre></td></tr></table></figure>
<ul>
<li>看一眼某个地方的字条 (只能看到瞬间的字)</li>
<li>刚看完就可能被改掉</li>
</ul>
</li>
</ul>
<p>对应于 model checker</p>
<ul>
<li>每一行可以执行一次全局变量读或写</li>
<li>每个操作执行之后都发生 <code>sys_sched()</code></li>
</ul>
<h3 id="正确性不明的奇怪尝试-Peterson-算法"><a href="#正确性不明的奇怪尝试-Peterson-算法" class="headerlink" title="正确性不明的奇怪尝试 (Peterson 算法)"></a>正确性不明的奇怪尝试 (Peterson 算法)</h3><p>A 和 B 争用厕所的包厢</p>
<ul>
<li><p>想进入包厢之前，A/B 都首先举起自己的旗子</p>
<ul>
<li>A 往厕所门上贴上 “B 正在使用” 的标签</li>
<li>B 往厕所门上贴上 “A 正在使用” 的标签</li>
</ul>
</li>
<li><p>然后，</p>
<p>如果对方举着旗，且门上的名字是对方</p>
<p>，等待</p>
<ul>
<li>否则可以进入包厢</li>
</ul>
</li>
<li><p>出包厢后，放下自己的旗子 (完全不管门上的标签)</p>
</li>
</ul>
<h3 id="习题：证明-Peterson-算法正确，或给出反例"><a href="#习题：证明-Peterson-算法正确，或给出反例" class="headerlink" title="习题：证明 Peterson 算法正确，或给出反例"></a>习题：证明 Peterson 算法正确，或给出反例</h3><p>进入临界区的情况</p>
<ul>
<li>如果只有一个人举旗，他就可以直接进入</li>
<li>如果两个人同时举旗，由厕所门上的标签决定谁进<ul>
<li>手快 🈶️ (被另一个人的标签覆盖)、手慢 🈚</li>
</ul>
</li>
</ul>
<p>一些具体的细节情况</p>
<ul>
<li>A 看到 B 没有举旗<ul>
<li>B 一定不在临界区</li>
<li>或者 B 想进但还没来得及把 “A 正在使用” 贴在门上</li>
</ul>
</li>
<li>A 看到 B 举旗子<ul>
<li>A 一定已经把旗子举起来了</li>
<li>(<em>!@^#</em>&amp;!%^(&amp;^!@%#</li>
</ul>
</li>
</ul>
<h3 id="绕来绕去很容易有错漏的情况"><a href="#绕来绕去很容易有错漏的情况" class="headerlink" title="绕来绕去很容易有错漏的情况"></a>绕来绕去很容易有错漏的情况</h3><p>Prove by brute-force</p>
<ul>
<li>枚举状态机的全部状态(<em>P**C</em>1,<em>P**C</em>2,<em>x</em>,<em>y</em>,<em>t<strong>u</strong>r**n</em>)</li>
<li>但手写还是很容易错啊——可执行的状态机模型有用了！</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">void TA() &#123; while (1) &#123;</span><br><span class="line">/* ❶ */  x = 1;</span><br><span class="line">/* ❷ */  turn = B;</span><br><span class="line">/* ❸ */  while (y &amp;&amp; turn == B) ;</span><br><span class="line">/* ❹ */  x = 0; &#125; &#125;</span><br><span class="line"></span><br><span class="line">void TB() &#123; while (1) &#123;</span><br><span class="line">/* ① */  y = 1;</span><br><span class="line">/* ② */  turn = A;</span><br><span class="line">/* ③ */  while (x &amp;&amp; turn == A) ;</span><br><span class="line">/* ④ */  y = 0; &#125; &#125;</span><br></pre></td></tr></table></figure>
<h2 id="模型、模型检验与现实"><a href="#模型、模型检验与现实" class="headerlink" title="模型、模型检验与现实"></a>模型、模型检验与现实</h2><h3 id="“Push-button”-Verification-🎖"><a href="#“Push-button”-Verification-🎖" class="headerlink" title="“Push-button” Verification 🎖"></a>“Push-button” Verification 🎖</h3><blockquote>
<p>我们 (在完全不理解算法的前提下) 证明了 Sequential 内存模型下 Peterson’s Protocol 的 Safety。它能够实现互斥。</p>
</blockquote>
<p>并发编程比大家想象得困难</p>
<ul>
<li>感受一下 <a target="_blank" rel="noopener" href="https://series1.github.io/blog/dekkers-algorithm/">Dekker’s Algorithm</a></li>
<li>“<a target="_blank" rel="noopener" href="https://zoo.cs.yale.edu/classes/cs323/doc/Peterson.pdf">Myths about the mutual exclusion problem</a>” (IPL, 1981)</li>
</ul>
<p><img src="../img/peterson-paper.png" alt="img"></p>
<h3 id="自动遍历状态空间的乐趣"><a href="#自动遍历状态空间的乐趣" class="headerlink" title="自动遍历状态空间的乐趣"></a>自动遍历状态空间的乐趣</h3><p>可以帮助我们快速回答更多问题</p>
<ul>
<li>如果结束后把门上的字条撕掉，算法还正确吗？<ul>
<li>在放下旗子之前撕</li>
<li>在放下旗子之后撕</li>
</ul>
</li>
<li>如果先贴标签再举旗，算法还正确吗？</li>
<li>我们有两个 “查看” 的操作<ul>
<li>看对方的旗有没有举起来</li>
<li>看门上的贴纸是不是自己</li>
<li>这两个操作的顺序影响算法的正确性吗？</li>
</ul>
</li>
<li>是否存在 “两个人谁都无法进入临界区” (liveness)、“对某一方不公平” (fairness) 等行为？<ul>
<li>都转换成图 (状态空间) 上的遍历问题了！</li>
</ul>
</li>
</ul>
<p>peterson.py</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">def T1():</span><br><span class="line">  while True:</span><br><span class="line">    heap.x = &#x27;🏴&#x27;</span><br><span class="line">    sys_sched()</span><br><span class="line">    heap.turn = &#x27;❷&#x27;</span><br><span class="line">    sys_sched()</span><br><span class="line">    while True:</span><br><span class="line">      t = heap.turn</span><br><span class="line">      sys_sched()</span><br><span class="line">      y = heap.y != &#x27;&#x27;</span><br><span class="line">      sys_sched()</span><br><span class="line">      if not y or t == &#x27;❶&#x27;:</span><br><span class="line">        break</span><br><span class="line">    sys_sched()</span><br><span class="line">    heap.cs += &#x27;❶&#x27;</span><br><span class="line">    sys_sched()</span><br><span class="line">    heap.cs = heap.cs.replace(&#x27;❶&#x27;, &#x27;&#x27;)</span><br><span class="line">    sys_sched()</span><br><span class="line">    heap.x = &#x27;&#x27;</span><br><span class="line">    sys_sched()</span><br><span class="line"> </span><br><span class="line">def T2():</span><br><span class="line">  while True:</span><br><span class="line">    heap.y = &#x27;🏁&#x27;</span><br><span class="line">    sys_sched()</span><br><span class="line">    heap.turn = &#x27;❶&#x27;</span><br><span class="line">    sys_sched()</span><br><span class="line">    while True:</span><br><span class="line">      t = heap.turn</span><br><span class="line">      sys_sched()</span><br><span class="line">      x = heap.x</span><br><span class="line">      sys_sched()</span><br><span class="line">      if not x or t == &#x27;❷&#x27;:</span><br><span class="line">        break</span><br><span class="line">      sys_sched()</span><br><span class="line">    sys_sched()</span><br><span class="line">    heap.cs += &#x27;❷&#x27;</span><br><span class="line">    sys_sched()</span><br><span class="line">    heap.cs = heap.cs.replace(&#x27;❷&#x27;, &#x27;&#x27;)</span><br><span class="line">    sys_sched()</span><br><span class="line">    heap.y = &#x27;&#x27;</span><br><span class="line">    sys_sched()</span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">  heap.x = &#x27;&#x27;</span><br><span class="line">  heap.y = &#x27;&#x27;</span><br><span class="line">  heap.turn = &#x27;&#x27;</span><br><span class="line">  heap.cs = &#x27;&#x27;</span><br><span class="line">  sys_spawn(T1)</span><br><span class="line">  sys_spawn(T2)</span><br></pre></td></tr></table></figure>
<p><img src="../img/image-164-1024x236.png" alt="img">验证了正确性</p>
<h3 id="从模型回到现实……"><a href="#从模型回到现实……" class="headerlink" title="从模型回到现实……"></a>从模型回到现实……</h3><p>回到我们的假设 (体现在模型)</p>
<ul>
<li>Atomic load &amp; store<ul>
<li>读/写单个全局变量是 “原子不可分割” 的</li>
<li>但这个假设在现代多处理器上并不成立</li>
</ul>
</li>
<li>所以实际上按照模型直接写 Peterson 算法应该是错的？</li>
</ul>
<p>“实现正确的 Peterson 算法” 是合理需求，它一定能实现</p>
<ul>
<li><p>Compiler barrier/volatile 保证不被优化的前提下</p>
<ul>
<li><p>处理器提供特殊指令保证可见性</p>
</li>
<li><p>编译器提供 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__sync_synchronize()</span><br></pre></td></tr></table></figure>
<p> 函数</p>
<ul>
<li>x86: <code>mfence</code>; ARM: <code>dmb ish</code>; RISC-V: <code>fence rw, rw</code></li>
<li>同时含有一个 compiler barrier</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>peterson.c</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;thread.h&quot;</span><br><span class="line"></span><br><span class="line">#define A 1</span><br><span class="line">#define B 2</span><br><span class="line"></span><br><span class="line">#define BARRIER __sync_synchronize()</span><br><span class="line"></span><br><span class="line">atomic_int nested;</span><br><span class="line">atomic_long count;</span><br><span class="line"></span><br><span class="line">void critical_section() &#123;</span><br><span class="line">  long cnt = atomic_fetch_add(&amp;count, 1);</span><br><span class="line">  int i = atomic_fetch_add(&amp;nested, 1) + 1;</span><br><span class="line">  if (i != 1) &#123;</span><br><span class="line">    printf(&quot;%d threads in the critical section @ count=%ld\n&quot;, i, cnt);</span><br><span class="line">    assert(0);</span><br><span class="line">  &#125;</span><br><span class="line">  atomic_fetch_add(&amp;nested, -1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int volatile x = 0, y = 0, turn;</span><br><span class="line"></span><br><span class="line">void TA() &#123;</span><br><span class="line">  while (1) &#123;</span><br><span class="line">    x = 1;                   BARRIER;</span><br><span class="line">    turn = B;                BARRIER; // &lt;- this is critcal for x86</span><br><span class="line">    while (1) &#123;</span><br><span class="line">      if (!y) break;         BARRIER;</span><br><span class="line">      if (turn != B) break;  BARRIER;</span><br><span class="line">    &#125;</span><br><span class="line">    critical_section();</span><br><span class="line">    x = 0;                   BARRIER;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void TB() &#123;</span><br><span class="line">  while (1) &#123;</span><br><span class="line">    y = 1;                   BARRIER;</span><br><span class="line">    turn = A;                BARRIER;</span><br><span class="line">    while (1) &#123;</span><br><span class="line">      if (!x) break;         BARRIER;</span><br><span class="line">      if (turn != A) break;  BARRIER;</span><br><span class="line">    &#125;</span><br><span class="line">    critical_section();</span><br><span class="line">    y = 0;                   BARRIER;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">  create(TA);</span><br><span class="line">  create(TB);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果把第六行的<strong>BARRIER</strong>定义为空，则会出错</p>
<p><img src="../img/image-169.png" alt="img">出错</p>
<h2 id="原子指令"><a href="#原子指令" class="headerlink" title="原子指令"></a>原子指令</h2><h3 id="并发编程困难的解决"><a href="#并发编程困难的解决" class="headerlink" title="并发编程困难的解决"></a>并发编程困难的解决</h3><p>普通的变量读写在编译器 + 处理器的双重优化下行为变得复杂</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">retry:</span><br><span class="line">  if (locked != UNLOCK) &#123;</span><br><span class="line">    goto retry;</span><br><span class="line">  &#125;</span><br><span class="line">  locked = LOCK;</span><br></pre></td></tr></table></figure>
<p>解决方法：编译器和硬件共同提供不可优化、不可打断的指令</p>
<ul>
<li>“原子指令” + compiler barrier</li>
</ul>
<h3 id="实现正确的求和"><a href="#实现正确的求和" class="headerlink" title="实现正确的求和"></a>实现正确的求和</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for (int i = 0; i &lt; N; i++)</span><br><span class="line">  asm volatile(&quot;lock incq %0&quot; : &quot;+m&quot;(sum));</span><br></pre></td></tr></table></figure>
<p>“Bus lock”——从 80386 开始引入 (bus control signal)</p>
<p><img src="../img/image-171-1024x741.png" alt="img"></p>
<p>sum-atomic.c</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;thread.h&quot;</span><br><span class="line"></span><br><span class="line">#define N 100000000</span><br><span class="line"></span><br><span class="line">long sum = 0;</span><br><span class="line"></span><br><span class="line">void atomic_inc(long *ptr) &#123;</span><br><span class="line">  asm volatile(</span><br><span class="line">    &quot;lock incq %0&quot;  // Atomic + memory fence</span><br><span class="line">    : &quot;+m&quot;(*ptr)</span><br><span class="line">    :</span><br><span class="line">    : &quot;memory&quot;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Tsum() &#123;</span><br><span class="line">  for (int i = 0; i &lt; N; i++) &#123;</span><br><span class="line">    atomic_inc(&amp;sum);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">  create(Tsum);</span><br><span class="line">  create(Tsum);</span><br><span class="line">  join();</span><br><span class="line">  printf(&quot;sum = %ld\n&quot;, sum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="../img/image-170.png" alt="img">正确结果，但是很慢</p>
<h3 id="编译器和硬件的协作"><a href="#编译器和硬件的协作" class="headerlink" title="编译器和硬件的协作"></a>编译器和硬件的协作</h3><p>Acquire/release semantics</p>
<ul>
<li><p>对于一对配对的 release-acquire</p>
<ul>
<li>(逻辑上) release 之前的 store 都对 acquire 之后的 load 可见</li>
<li><a target="_blank" rel="noopener" href="https://davekilian.com/acquire-release.html">Making Sense of Acquire-Release Semantics</a></li>
</ul>
</li>
<li><p>std::atomic</p>
<ul>
<li><p>std::memory_order_acquire: guarantees that subsequent loads are not moved before the current load or any preceding loads.</p>
</li>
<li><p>std::memory_order_release: preceding stores are not moved past the current store or any subsequent stores.</p>
</li>
<li><p><code>x.load()</code>/<code>x.store()</code> 会根据 <a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/atomic/memory_order">memory order</a> 插入 fence</p>
</li>
<li><p><code>x.fetch_add()</code></p>
<p> 将会保证 cst (sequentially consistent)</p>
<ul>
<li>去 <a target="_blank" rel="noopener" href="https://godbolt.org/">godbolt</a> 上试一下吧</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="并发3-并发控制：互斥-2023-3-14"><a href="#并发3-并发控制：互斥-2023-3-14" class="headerlink" title="并发3_并发控制：互斥_2023.3.14"></a>并发3_并发控制：互斥_2023.3.14</h1><h2 id="互斥问题：定义与假设"><a href="#互斥问题：定义与假设" class="headerlink" title="互斥问题：定义与假设"></a>互斥问题：定义与假设</h2><h3 id="互斥问题：定义"><a href="#互斥问题：定义" class="headerlink" title="互斥问题：定义"></a>互斥问题：定义</h3><p>互斥 (mutual exclusion)，“互相排斥”</p>
<ul>
<li>实现 <code>lock_t</code> 数据结构和 <code>lock/unlock</code> API:</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  ...</span><br><span class="line">&#125; <span class="type">lock_t</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">lock</span><span class="params">(<span class="type">lock_t</span> *lk)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">unlock</span><span class="params">(<span class="type">lock_t</span> *lk)</span>;</span><br></pre></td></tr></table></figure>
<p>一把 “排他性” 的锁——对于锁对象 <code>lk</code></p>
<ul>
<li>如果某个线程持有锁，则其他线程的 <code>lock</code> 不能返回 (Safety)</li>
<li>在多个线程执行 <code>lock</code> 时，至少有一个可以返回 (Liveness)</li>
<li>能正确处理处理器乱序、宽松内存模型和编译优化</li>
</ul>
<h3 id="互斥问题的经典算法"><a href="#互斥问题的经典算法" class="headerlink" title="互斥问题的经典算法"></a>互斥问题的经典算法</h3><p>Peterson 算法</p>
<ul>
<li>包间、旗子和门上的字条</li>
<li>假设 atomic load/store<ul>
<li>实现这个假设也不是非常容易的 (<a target="_blank" rel="noopener" href="https://jyywiki.cn/pages/OS/2023/c/peterson.c">peterson.c</a>)</li>
</ul>
</li>
</ul>
<p>因此，假设很重要</p>
<ul>
<li>不能同时读/写共享内存 (1960s) 不是一个好的假设<ul>
<li>Load (环顾四周) 的时候不能写，“看一眼就把眼睛闭上”</li>
<li>Store (改变物理世界状态) 的时候不能读，“闭着眼睛动手”</li>
<li>这是《操作系统&gt;课<ul>
<li>更喜欢直观、简单、粗暴 (稳定)、有效的解决方法</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="实现互斥的基本假设"><a href="#实现互斥的基本假设" class="headerlink" title="实现互斥的基本假设"></a>实现互斥的基本假设</h3><p>允许使用使我们可以不管一切麻烦事的原子指令</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">void atomic_inc(long *ptr);</span><br><span class="line">int atomic_xchg(int val, int *ptr);</span><br></pre></td></tr></table></figure>
<p>看起来是一个普通的函数，但假设：</p>
<ul>
<li>包含一个原子指令<ul>
<li>指令的执行不能被打断</li>
</ul>
</li>
<li>包含一个 compiler barrier<ul>
<li>无论何种优化都不可越过此函数</li>
</ul>
</li>
<li>包含一个 memory fence<ul>
<li>保证处理器在 stop-the-world 前所有对内存的 store 都 “生效”</li>
<li>即对 resume-the-world 之后的 load 可见</li>
</ul>
</li>
</ul>
<p>对未来可见：release；读到过去的内容：acquire。共同组成锁。</p>
<h3 id="Atomic-Exchange-实现"><a href="#Atomic-Exchange-实现" class="headerlink" title="Atomic Exchange 实现"></a>Atomic Exchange 实现</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">int xchg(int volatile *ptr, int newval) &#123;</span><br><span class="line">  int result;</span><br><span class="line">  asm volatile(</span><br><span class="line">    // 指令自带 memory barrier</span><br><span class="line">    &quot;lock xchgl %0, %1&quot;</span><br><span class="line">    : &quot;+m&quot;(*ptr), &quot;=a&quot;(result)</span><br><span class="line">    : &quot;1&quot;(newval)</span><br><span class="line">    // Compiler barrier</span><br><span class="line">    : &quot;memory&quot;</span><br><span class="line">  );</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="自旋锁-Spin-Lock"><a href="#自旋锁-Spin-Lock" class="headerlink" title="自旋锁 (Spin Lock)"></a>自旋锁 (Spin Lock)</h2><h3 id="自旋锁-Spin-Lock-1"><a href="#自旋锁-Spin-Lock-1" class="headerlink" title="自旋锁 (Spin Lock)"></a>自旋锁 (Spin Lock)</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">void lock(lock_t *lk);</span><br><span class="line">void unlock(lock_t *lk);</span><br></pre></td></tr></table></figure>
<p>做题家：拿到题就开始排列组合</p>
<ul>
<li>熟练得让人心疼<ul>
<li>如果长久的训练都是 “必须在规定的时间内正确解出问题”，那么浪费时间的思考自然就少了</li>
</ul>
</li>
</ul>
<p>科学家：考虑更多更根本的问题</p>
<ul>
<li>我们可以设计出怎样的原子指令？<ul>
<li>它们的表达能力如何？</li>
</ul>
</li>
<li>计算机硬件可以提供比 “一次 load/store” 更强的原子性吗？<ul>
<li>如果硬件很困难，软件/编译器可以么？</li>
</ul>
</li>
</ul>
<h3 id="自旋锁：用-xchg-实现互斥"><a href="#自旋锁：用-xchg-实现互斥" class="headerlink" title="自旋锁：用 xchg 实现互斥"></a>自旋锁：用 <code>xchg</code> 实现互斥</h3><p>在厕所门口放一个桌子 (共享变量)</p>
<ul>
<li>初始时放着 🔑</li>
</ul>
<p>自旋锁 (Spin Lock)</p>
<ul>
<li>想上厕所的同学 (一条 xchg 指令)<ul>
<li>Stop the world</li>
<li>看一眼桌子上有什么 (🔑 或 🔞)</li>
<li>把 🔞 放到桌上 (覆盖之前有的任何东西)</li>
<li>Resume the world</li>
<li>期间看到 🔑 才可以进厕所，否则重复</li>
</ul>
</li>
<li>出厕所的同学<ul>
<li>把 🔑 放到桌上</li>
</ul>
</li>
</ul>
<h3 id="实现互斥：自旋锁"><a href="#实现互斥：自旋锁" class="headerlink" title="实现互斥：自旋锁"></a>实现互斥：自旋锁</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">int table = YES;</span><br><span class="line"></span><br><span class="line">void lock() &#123;</span><br><span class="line">retry:</span><br><span class="line">  int got = xchg(&amp;table, NOPE);</span><br><span class="line">  if (got == NOPE)</span><br><span class="line">    goto retry;</span><br><span class="line">  assert(got == YES);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void unlock() &#123;</span><br><span class="line">  xchg(&amp;table, YES);  // 为什么不是 table = YES; ?</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 xchg 的假设下简化实现</p>
<ul>
<li>包含一个原子指令</li>
<li>包含一个 compiler barrier</li>
<li>包含一个 memory fence<ul>
<li>sum-spinlock demo</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int locked = 0;</span><br><span class="line"></span><br><span class="line">void lock() &#123;</span><br><span class="line">  while (xchg(&amp;locked, 1));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void unlock() &#123;</span><br><span class="line">  xchg(&amp;locked, 0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>sum-spinlock.c</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;thread.h&quot;</span><br><span class="line"></span><br><span class="line">#define N 100000000</span><br><span class="line">#define M 10</span><br><span class="line"></span><br><span class="line">long sum = 0;</span><br><span class="line"></span><br><span class="line">int xchg(int volatile *ptr, int newval) &#123;</span><br><span class="line">  int result;</span><br><span class="line">  asm volatile(</span><br><span class="line">    &quot;lock xchgl %0, %1&quot;</span><br><span class="line">    : &quot;+m&quot;(*ptr), &quot;=a&quot;(result)</span><br><span class="line">    : &quot;1&quot;(newval)</span><br><span class="line">    : &quot;memory&quot;</span><br><span class="line">  );</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int locked = 0;</span><br><span class="line"></span><br><span class="line">void lock() &#123;</span><br><span class="line">  while (xchg(&amp;locked, 1)) ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void unlock() &#123;</span><br><span class="line">  xchg(&amp;locked, 0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Tsum() &#123;</span><br><span class="line">  long nround = N / M;</span><br><span class="line">  for (int i = 0; i &lt; nround; i++) &#123;</span><br><span class="line">    lock();</span><br><span class="line">    for (int j = 0; j &lt; M; j++) &#123;</span><br><span class="line">      sum++;  // Non-atomic; can optimize</span><br><span class="line">    &#125;</span><br><span class="line">    unlock();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">  assert(N % M == 0);</span><br><span class="line">  create(Tsum);</span><br><span class="line">  create(Tsum);</span><br><span class="line">  join();</span><br><span class="line">  printf(&quot;sum = %ld\n&quot;, sum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果sum = 200000000</p>
<h2 id="更强大的原子指令"><a href="#更强大的原子指令" class="headerlink" title="更强大的原子指令"></a>更强大的原子指令</h2><h3 id="更强大的原子指令-1"><a href="#更强大的原子指令-1" class="headerlink" title="更强大的原子指令"></a>更强大的原子指令</h3><p>Compare and exchange (“test and set”)</p>
<p>Compare and exchange (“test and set”)</p>
<ul>
<li>(lock) cmpxchg SRC, DEST</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">TEMP = DEST</span><br><span class="line">if accumulator == TEMP:</span><br><span class="line">    ZF = 1</span><br><span class="line">    DEST = SRC</span><br><span class="line">else:</span><br><span class="line">    ZF = 0</span><br><span class="line">    accumulator = TEMP</span><br></pre></td></tr></table></figure>
<ul>
<li>🤔 看起来没复杂多少，好像又复杂了很多<ul>
<li>学编程/操作系统 “纸面理解” 是不行的</li>
<li>一定要写代码加深印象<ul>
<li>对于这个例子：我们可以列出 “真值表”</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="在自旋锁中代替-xchg"><a href="#在自旋锁中代替-xchg" class="headerlink" title="在自旋锁中代替 xchg"></a>在自旋锁中代替 xchg</h3><p>在自旋锁中代替 xchg</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// cmpxchg(old=&#x27;🔑&#x27;, new=&#x27;🔞&#x27;, *ptr)</span><br><span class="line">int tmp = *ptr;</span><br><span class="line">if (tmp == &#x27;🔑&#x27;) &#123;</span><br><span class="line">  *ptr = &#x27;🔞&#x27;</span><br><span class="line">  assert(tmp == &#x27;🔑&#x27;);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  assert(tmp == &#x27;🔞&#x27;);</span><br><span class="line">&#125;</span><br><span class="line">return tmp;</span><br></pre></td></tr></table></figure>
<ul>
<li>这么做有什么好处吗？<ul>
<li>有的，在自旋失败的时候减少了一次 store</li>
<li>当然，现代处理器也可以优化 xchg</li>
</ul>
</li>
</ul>
<h3 id="多出的-Compare-用处"><a href="#多出的-Compare-用处" class="headerlink" title="多出的 Compare: 用处"></a>多出的 Compare: 用处</h3><p>同时检查上一次获得的值是否仍然有效 + 修改生效</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// Create a new node</span><br><span class="line">retry:</span><br><span class="line">  expected = head;</span><br><span class="line">  node-&gt;next = expected;</span><br><span class="line">  seen = cmpxchg(expected, node, &amp;head);</span><br><span class="line">  if (seen != expected)</span><br><span class="line">    goto retry;</span><br></pre></td></tr></table></figure>
<h2 id="在操作系统上实现互斥"><a href="#在操作系统上实现互斥" class="headerlink" title="在操作系统上实现互斥"></a>在操作系统上实现互斥</h2><h3 id="自旋锁的缺陷"><a href="#自旋锁的缺陷" class="headerlink" title="自旋锁的缺陷"></a>自旋锁的缺陷</h3><p>性能问题 (1)</p>
<ul>
<li>除了进入临界区的线程，其他处理器上的线程都在空转</li>
<li>争抢锁的处理器越多，利用率越低<ul>
<li>4 个 CPU 运行 4 个 sum-spinlock 和 1 个 OBS<ul>
<li>任意时刻都只有一个 sum-atomic 在有效计算</li>
</ul>
</li>
<li>均分 CPU, OBS 就分不到 100% 的 CPU 了</li>
</ul>
</li>
</ul>
<p>性能问题 (2)</p>
<ul>
<li>持有自旋锁的线程可能被操作系统切换出去<ul>
<li>操作系统不 “感知” 线程在做什么</li>
<li>(但为什么不能呢？)</li>
</ul>
</li>
<li>实现 100% 的资源浪费</li>
</ul>
<h3 id="Scalability-性能的新维度"><a href="#Scalability-性能的新维度" class="headerlink" title="Scalability: 性能的新维度"></a>Scalability: 性能的新维度</h3><blockquote>
<p>同一份计算任务，时间 (CPU cycles) 和空间 (mapped memory) 会随处理器数量的增长而变化。</p>
</blockquote>
<p><img src="../img/spinlock-scalability.jpg" alt="img"></p>
<p>用自旋锁实现 sum++ 的性能问题</p>
<ul>
<li>严谨的统计很难<ul>
<li>CPU 动态功耗</li>
<li>系统中的其他进程</li>
<li>超线程</li>
<li>NUMA</li>
<li>……</li>
<li><a target="_blank" rel="noopener" href="https://www.cse.unsw.edu.au/~gernot/benchmarking-crimes.html">Benchmarking crimes</a></li>
</ul>
</li>
</ul>
<h3 id="自旋锁的使用场景"><a href="#自旋锁的使用场景" class="headerlink" title="自旋锁的使用场景"></a>自旋锁的使用场景</h3><ol>
<li>临界区几乎不 “拥堵”</li>
<li>持有自旋锁时禁止执行流切换</li>
</ol>
<p>使用场景：操作系统内核的并发数据结构 (短临界区)</p>
<ul>
<li>操作系统可以关闭中断和抢占<ul>
<li>保证锁的持有者在很短的时间内可以释放锁</li>
</ul>
</li>
<li>(如果是虚拟机呢…😂)<ul>
<li>PAUSE 指令会触发 VM Exit</li>
</ul>
</li>
<li>但依旧很难做好<ul>
<li><a target="_blank" rel="noopener" href="https://www.usenix.org/conference/osdi10/analysis-linux-scalability-many-cores">An analysis of Linux scalability to many cores</a> (OSDI’10)</li>
</ul>
</li>
</ul>
<h3 id="实现线程-长临界区的互斥"><a href="#实现线程-长临界区的互斥" class="headerlink" title="实现线程 + 长临界区的互斥"></a>实现线程 + 长临界区的互斥</h3><p>“让” 不是 C 语言代码可以做到的 (C 代码只能执行指令)</p>
<ul>
<li><p>但有一种特殊的指令：syscall</p>
</li>
<li><p>把锁的实现放到操作系统里就好啦</p>
<ul>
<li><p>```<br>syscall(SYSCALL_lock, &amp;lk);</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  - 试图获得 `lk`，但如果失败，就切换到其他线程</span><br><span class="line"></span><br><span class="line">- ```</span><br><span class="line">  syscall(SYSCALL_unlock, &amp;lk);</span><br></pre></td></tr></table></figure>
<ul>
<li>释放 <code>lk</code>，如果有等待锁的线程就唤醒</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>操作系统 = 更衣室管理员</p>
<ul>
<li>先到的人 (线程)<ul>
<li>成功获得手环，进入游泳馆</li>
<li><code>*lk = 🔒</code>，系统调用直接返回</li>
</ul>
</li>
<li>后到的人 (线程)<ul>
<li>不能进入游泳馆，排队等待</li>
<li>线程放入等待队列，执行线程切换 (yield)</li>
</ul>
</li>
<li>洗完澡出来的人 (线程)<ul>
<li>交还手环给管理员；管理员把手环再交给排队的人</li>
<li>如果等待队列不空，从等待队列中取出一个线程允许执行</li>
<li>如果等待队列为空，<code>*lk = ✅</code></li>
</ul>
</li>
<li>管理员 (OS) 使用自旋锁确保自己处理手环的过程是原子的</li>
</ul>
<h1 id="并发4-并发控制：调试理论与实践-2023-3-16"><a href="#并发4-并发控制：调试理论与实践-2023-3-16" class="headerlink" title="并发4_并发控制：调试理论与实践_2023.3.16"></a>并发4_并发控制：调试理论与实践_2023.3.16</h1><h2 id="调试理论"><a href="#调试理论" class="headerlink" title="调试理论"></a>调试理论</h2><p>调试理论：如果我们能判定任意程序状态的正确性，那么给定一个 failure，我们可以通过二分查找定位到第一个 error 的状态，此时的代码就是 fault (bug)。</p>
<p>实际中的调试：观察状态机执行 (trace) 的某个侧面</p>
<ul>
<li>缩小错误状态 (error) 可能产生的位置</li>
<li>作出适当的假设</li>
<li>再进行细粒度的定位和诊断</li>
</ul>
<p>最重要的两个工具</p>
<ul>
<li>printf → 自定义 log 的 trace<ul>
<li>灵活可控、能快速定位问题大概位置、适用于大型软件</li>
<li>无法精确定位、大量的 logs 管理起来比较麻烦</li>
</ul>
</li>
<li>gdb → 指令/语句级 trace<ul>
<li>精确、指令级定位、任意查看程序内部状态</li>
<li>耗费大量时间</li>
</ul>
</li>
</ul>
<h2 id="使用-GDB-调试程序"><a href="#使用-GDB-调试程序" class="headerlink" title="使用 GDB 调试程序"></a>使用 GDB 调试程序</h2><h2 id="GDB-入门"><a href="#GDB-入门" class="headerlink" title="GDB: 入门"></a>GDB: 入门</h2><p>GDB: 最常用的命令在 <a target="_blank" rel="noopener" href="https://jyywiki.cn/pages/OS/manuals/gdb-cheat-sheet.pdf">gdb cheat sheet</a></p>
<ul>
<li>打印贴在电脑前，调试时候看一遍，很快就大致记住了</li>
</ul>
<p>想要更好的体验？</p>
<ul>
<li>GDB 本身也是一个编程语言<ul>
<li>它甚至支持 Python</li>
<li>我们可以执行一些初始化代码 (-x)</li>
</ul>
</li>
<li>库函数也是代码<ul>
<li>directory 命令增加源码路径</li>
</ul>
</li>
<li>GDB 有许多前端<ul>
<li>cgdb, pwndbg, vscode, …</li>
</ul>
</li>
<li><a target="_blank" rel="noopener" href="https://sourceware.org/gdb/current/onlinedocs/gdb.html/">RTFM</a> - M 比 ChatGPT 好用在于它不需要 prompt 且全面</li>
</ul>
<p><strong>musl</strong></p>
<h2 id="🌶️-Futex-Fast-Userspace-muTexes-cont’d"><a href="#🌶️-Futex-Fast-Userspace-muTexes-cont’d" class="headerlink" title="🌶️ Futex: Fast Userspace muTexes (cont’d)"></a>🌶️ Futex: Fast Userspace muTexes (cont’d)</h2><p>一个简单的设计：先在用户空间自旋</p>
<ul>
<li>如果获得锁，直接进入 (Fast Path，无系统调用)</li>
<li>未能获得锁，系统调用 (Slow Path)</li>
<li>解锁后用系统调用唤醒潜在的 Slow Path 线程<ul>
<li>更好的设计可以彻底消除 fast-path 的系统调用</li>
</ul>
</li>
</ul>
<p>RTFM (劝退)</p>
<ul>
<li>futex (7), futex (2)</li>
<li><a target="_blank" rel="noopener" href="https://lwn.net/Articles/360699/">A futex overview and update</a> (LWN)</li>
<li><a target="_blank" rel="noopener" href="https://jyywiki.cn/pages/OS/manuals/futexes-are-tricky.pdf">Futexes are tricky</a> (论 model checker 的重要性)</li>
<li>(我们不讲并发算法)<ul>
<li>但我们可以调试它的实现</li>
</ul>
</li>
</ul>
<h2 id="调试理论：应用"><a href="#调试理论：应用" class="headerlink" title="调试理论：应用"></a>调试理论：应用</h2><h2 id="调试理论：应用-Again"><a href="#调试理论：应用-Again" class="headerlink" title="调试理论：应用 (Again)"></a>调试理论：应用 (Again)</h2><p>需求 → 设计 → 代码 → Fault → Error → Failure</p>
<p>“Technical Debt”</p>
<blockquote>
<p>每当你写出不好维护的代码，你都在给你未来的调试/需求变更挖坑。</p>
<p>中枪了？</p>
</blockquote>
<ul>
<li>为了快点跑程序，随便写的 klib</li>
<li>为了赶紧实现指令，随手写的代码</li>
<li>为了应付老板，随便写的系统实现<ul>
<li>jyy 的 code review: <del>日常血压升高时间</del></li>
</ul>
</li>
</ul>
<h2 id="编程基本准则：回顾"><a href="#编程基本准则：回顾" class="headerlink" title="编程基本准则：回顾"></a>编程基本准则：回顾</h2><blockquote>
<p>Programs are meant to be read by humans (AIs) and only incidentally for computers to execute. — <em>D. E. Knuth</em></p>
<p>(程序首先是拿给人读的，其次才是被机器执行。)</p>
</blockquote>
<p>好的程序</p>
<ul>
<li><p>不言自明：能知道是做什么的 (</p>
<p>specification</p>
<p>)</p>
<ul>
<li>因此代码风格很重要</li>
</ul>
</li>
<li><p>不言自证：能确认代码和 specification 一致</p>
<ul>
<li>因此代码中的逻辑流很重要</li>
</ul>
</li>
<li><p>人类新纪元的评判标准</p>
<ul>
<li>AI 是否能正确理解/维护你的代码</li>
</ul>
</li>
</ul>
<h2 id="调试理论的最重要应用"><a href="#调试理论的最重要应用" class="headerlink" title="调试理论的最重要应用"></a>调试理论的最重要应用</h2><blockquote>
<p>写好读、易验证的代码</p>
<p>在代码中添加更多的断言 (assertions)</p>
</blockquote>
<p>断言的意义</p>
<ul>
<li>把代码中隐藏的 specification 写出来<ul>
<li>Fault → Error (靠测试)</li>
<li>Error → Failure (靠断言)<ul>
<li>Error 暴露的越晚，越难调试</li>
<li>追溯导致 assert failure 的变量值 (slice) 通常可以快速定位到 bug</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="并发5-并发控制：同步-1-2023-3-21"><a href="#并发5-并发控制：同步-1-2023-3-21" class="headerlink" title="并发5_并发控制：同步 (1)_2023.3.21"></a>并发5_并发控制：同步 (1)_2023.3.21</h1><h2 id="同步问题"><a href="#同步问题" class="headerlink" title="同步问题"></a>同步问题</h2><h2 id="同步-Synchronization"><a href="#同步-Synchronization" class="headerlink" title="同步 (Synchronization)"></a>同步 (Synchronization)</h2><p><img src="../img/gearbox.gif" alt="img"></p>
<p>两个或两个以上随时间变化的量在变化过程中保持一定的相对关系</p>
<ul>
<li>同步电路 (一个时钟控制所有触发器)</li>
<li>iPhone/iCloud 同步 (手机 vs 电脑 vs 云端)</li>
<li>变速箱同步器 (合并快慢速齿轮)</li>
<li>同步电机 (转子与磁场转速一致)</li>
<li>同步电路 (所有触发器在边沿同时触发)</li>
</ul>
<hr>
<p>异步 (Asynchronous) = 不需要同步</p>
<ul>
<li>上述很多例子都有异步版本 (异步电机、异步电路、异步线程)</li>
</ul>
<h2 id="生产者-消费者问题：学废你就赢了"><a href="#生产者-消费者问题：学废你就赢了" class="headerlink" title="生产者-消费者问题：学废你就赢了"></a>生产者-消费者问题：学废你就赢了</h2><blockquote>
<p>99% 的实际并发问题都可以用生产者-消费者解决。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">void Tproduce() &#123; while (1) printf(&quot;(&quot;); &#125;</span><br><span class="line">void Tconsume() &#123; while (1) printf(&quot;)&quot;); &#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>printf</code> 前后增加代码，使得打印的括号序列满足</p>
<ul>
<li><p>一定是某个合法括号序列的前缀</p>
</li>
<li><p>括号嵌套的深度不超过 </p>
<p>n</p>
<ul>
<li><em>n</em>=3, <code>((())())(((</code> 合法</li>
<li><em>n</em>=3, <code>(((())))</code>, <code>(()))</code> 不合法</li>
</ul>
</li>
<li><p>生产者-消费者问题中的同步</p>
<ul>
<li>Tproduce: 等到有空位时才能打印左括号</li>
<li>Tconsume: 等到有多余的左括号时才能打印右括号</li>
</ul>
</li>
</ul>
<h2 id="计算图、调度器和生产者-消费者问题"><a href="#计算图、调度器和生产者-消费者问题" class="headerlink" title="计算图、调度器和生产者-消费者问题"></a>计算图、调度器和生产者-消费者问题</h2><p>为什么叫 “生产者-消费者” 而不是 “括号问题”？</p>
<ul>
<li>左括号：生产资源 (任务)、放入队列</li>
<li>右括号：从队列取出资源 (任务) 执行</li>
</ul>
<p>并行计算基础：计算图</p>
<ul>
<li>计算任务构成有向无环图<ul>
<li>(<em>u</em>,<em>v</em>)∈<em>E</em> 表示 <em>v</em> 要用到前<em>u</em> 的值</li>
</ul>
</li>
<li>只要调度器 (生产者) 分配任务效率够高，算法就能并行<ul>
<li>生产者把任务放入队列中</li>
<li>消费者 (workers) 从队列中取出任务</li>
</ul>
</li>
</ul>
<h2 id="生产者-消费者：实现"><a href="#生产者-消费者：实现" class="headerlink" title="生产者-消费者：实现"></a>生产者-消费者：实现</h2><p>能否用互斥锁实现括号问题？</p>
<ul>
<li>左括号：嵌套深度 (队列) 不足 <em>n</em> 时才能打印</li>
<li>右括号：嵌套深度 (队列) &gt;1&gt;1 时才能打印<ul>
<li>当然是等到满足条件时再打印了 (代码演示)<ul>
<li>用互斥锁保持条件成立</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>并发：小心！</p>
<ul>
<li>压力测试 + 观察输出结果</li>
<li>自动观察输出结果：<a target="_blank" rel="noopener" href="https://jyywiki.cn/pages/OS/2023/c/pc-check.py">pc-check.py</a></li>
<li>未来：copilot 观察输出结果，并给出修复建议</li>
<li><p>更远的未来：<del>我们都不需要不存在了</del></p>
<p>pc-mutex.c</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;thread.h&quot;</span><br><span class="line">#include &quot;thread-sync.h&quot;</span><br><span class="line"></span><br><span class="line">int n, count = 0;</span><br><span class="line">mutex_t lk = MUTEX_INIT();</span><br><span class="line"></span><br><span class="line">#define CAN_PRODUCE (count &lt; n)</span><br><span class="line">#define CAN_CONSUME (count &gt; 0)</span><br><span class="line"></span><br><span class="line">void Tproduce() &#123;</span><br><span class="line">  while (1) &#123;</span><br><span class="line">retry:</span><br><span class="line">    mutex_lock(&amp;lk);</span><br><span class="line">    if (!CAN_PRODUCE) &#123;</span><br><span class="line">      mutex_unlock(&amp;lk);</span><br><span class="line">      goto retry;</span><br><span class="line">    &#125;</span><br><span class="line">    count++;</span><br><span class="line">    printf(&quot;(&quot;);  // Push an element into buffer</span><br><span class="line">    mutex_unlock(&amp;lk);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Tconsume() &#123;</span><br><span class="line">  while (1) &#123;</span><br><span class="line">retry:</span><br><span class="line">    mutex_lock(&amp;lk);</span><br><span class="line">    if (!CAN_CONSUME) &#123;</span><br><span class="line">      mutex_unlock(&amp;lk);</span><br><span class="line">      goto retry;</span><br><span class="line">    &#125;</span><br><span class="line">    count--;</span><br><span class="line">    printf(&quot;)&quot;);  // Pop an element from buffer</span><br><span class="line">    mutex_unlock(&amp;lk);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[]) &#123;</span><br><span class="line">  assert(argc == 2);</span><br><span class="line">  n = atoi(argv[1]);</span><br><span class="line">  setbuf(stdout, NULL);</span><br><span class="line">  for (int i = 0; i &lt; 8; i++) &#123;</span><br><span class="line">    create(Tproduce);</span><br><span class="line">    create(Tconsume);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>thread-sync.h</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;semaphore.h&gt;</span><br><span class="line"></span><br><span class="line">// Spinlock</span><br><span class="line">typedef int spinlock_t;</span><br><span class="line">#define SPIN_INIT() 0</span><br><span class="line"></span><br><span class="line">static inline int atomic_xchg(volatile int *addr, int newval) &#123;</span><br><span class="line">  int result;</span><br><span class="line">  asm volatile (&quot;lock xchg %0, %1&quot;:</span><br><span class="line">    &quot;+m&quot;(*addr), &quot;=a&quot;(result) : &quot;1&quot;(newval) : &quot;memory&quot;);</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void spin_lock(spinlock_t *lk) &#123;</span><br><span class="line">  while (1) &#123;</span><br><span class="line">    intptr_t value = atomic_xchg(lk, 1);</span><br><span class="line">    if (value == 0) &#123;</span><br><span class="line">      break;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">void spin_unlock(spinlock_t *lk) &#123;</span><br><span class="line">  atomic_xchg(lk, 0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Mutex</span><br><span class="line">typedef pthread_mutex_t mutex_t;</span><br><span class="line">#define MUTEX_INIT() PTHREAD_MUTEX_INITIALIZER</span><br><span class="line">void mutex_lock(mutex_t *lk)   &#123; pthread_mutex_lock(lk); &#125;</span><br><span class="line">void mutex_unlock(mutex_t *lk) &#123; pthread_mutex_unlock(lk); &#125;</span><br><span class="line"></span><br><span class="line">// Conditional Variable</span><br><span class="line">typedef pthread_cond_t cond_t;</span><br><span class="line">#define COND_INIT() PTHREAD_COND_INITIALIZER</span><br><span class="line">#define cond_wait pthread_cond_wait</span><br><span class="line">#define cond_broadcast pthread_cond_broadcast</span><br><span class="line">#define cond_signal pthread_cond_signal</span><br><span class="line"></span><br><span class="line">// Semaphore</span><br><span class="line">#define P sem_wait</span><br><span class="line">#define V sem_post</span><br><span class="line">#define SEM_INIT(sem, val) sem_init(sem, 0, val)</span><br></pre></td></tr></table></figure>
<h2 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h2><h2 id="同步问题：分析"><a href="#同步问题：分析" class="headerlink" title="同步问题：分析"></a>同步问题：分析</h2><blockquote>
<p>线程同步由条件不成立等待和同步条件达成继续构成</p>
</blockquote>
<p>线程 join</p>
<ul>
<li>Tmain 同步条件：<code>nexit == T</code></li>
<li>Tmain 达成同步：最后一个线程退出 <code>nexit++</code></li>
</ul>
<p>生产者/消费者问题</p>
<ul>
<li>Tproduce 同步条件：<code>CAN_PRODUCE (count &lt; n)</code></li>
<li>Tproduce 达成同步：Tconsume <code>count--</code></li>
<li>Tconsume 同步条件：<code>CAN_CONSUME (count &gt; 0)</code></li>
<li>Tconsume 达成同步：Tproduce <code>count++</code></li>
</ul>
<h2 id="条件变量：理想与实现之间的折衷"><a href="#条件变量：理想与实现之间的折衷" class="headerlink" title="条件变量：理想与实现之间的折衷"></a>条件变量：理想与实现之间的折衷</h2><p>一把互斥锁 + 一个 “条件变量” + 手工唤醒</p>
<ul>
<li>wait(cv, mutex) 💤<ul>
<li>调用时必须保证已经获得 mutex</li>
<li>wait 释放 mutex、进入睡眠状态</li>
<li>被唤醒后需要重新执行 lock(mutex)</li>
</ul>
</li>
<li>signal/notify(cv) 💬<ul>
<li>随机私信一个等待者：醒醒</li>
<li>如果有线程正在等待 cv，则唤醒其中一个线程</li>
</ul>
</li>
<li>broadcast/notifyAll(cv) 📣<ul>
<li>叫醒所有人</li>
<li>唤醒全部正在等待 cv 的线程</li>
</ul>
</li>
</ul>
<h2 id="条件变量：应用"><a href="#条件变量：应用" class="headerlink" title="条件变量：应用"></a>条件变量：应用</h2><h2 id="条件变量：万能并行计算框架-M2"><a href="#条件变量：万能并行计算框架-M2" class="headerlink" title="条件变量：万能并行计算框架 (M2)"></a>条件变量：万能并行计算框架 (M2)</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">struct work &#123;</span><br><span class="line">  void (*run)(void *arg);</span><br><span class="line">  void *arg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Tworker() &#123;</span><br><span class="line">  while (1) &#123;</span><br><span class="line">    struct work *work;</span><br><span class="line">    wait_until(has_new_work() || all_done) &#123;</span><br><span class="line">      work = get_work();</span><br><span class="line">    &#125;</span><br><span class="line">    if (!work) break;</span><br><span class="line">    else &#123;</span><br><span class="line">      work-&gt;run(work-&gt;arg); // 允许生成新的 work (注意互斥)</span><br><span class="line">      release(work);  // 注意回收 work 分配的资源</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>fish.c</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;thread.h&quot;</span><br><span class="line">#include &quot;thread-sync.h&quot;</span><br><span class="line"></span><br><span class="line">#define LENGTH(arr) (sizeof(arr) / sizeof(arr[0]))</span><br><span class="line"></span><br><span class="line">enum &#123; A = 1, B, C, D, E, F, &#125;;</span><br><span class="line"></span><br><span class="line">struct rule &#123;</span><br><span class="line">  int from, ch, to;</span><br><span class="line">&#125; rules[] = &#123;</span><br><span class="line">  &#123; A, &#x27;&lt;&#x27;, B &#125;,</span><br><span class="line">  &#123; B, &#x27;&gt;&#x27;, C &#125;,</span><br><span class="line">  &#123; C, &#x27;&lt;&#x27;, D &#125;,</span><br><span class="line">  &#123; A, &#x27;&gt;&#x27;, E &#125;,</span><br><span class="line">  &#123; E, &#x27;&lt;&#x27;, F &#125;,</span><br><span class="line">  &#123; F, &#x27;&gt;&#x27;, D &#125;,</span><br><span class="line">  &#123; D, &#x27;_&#x27;, A &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">int current = A, quota = 1;</span><br><span class="line"></span><br><span class="line">mutex_t lk = MUTEX_INIT();</span><br><span class="line">cond_t cv = COND_INIT();</span><br><span class="line"></span><br><span class="line">int next(char ch) &#123;</span><br><span class="line">  for (int i = 0; i &lt; LENGTH(rules); i++) &#123;</span><br><span class="line">    struct rule *rule = &amp;rules[i];</span><br><span class="line">    if (rule-&gt;from == current &amp;&amp; rule-&gt;ch == ch) &#123;</span><br><span class="line">      return rule-&gt;to;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static int can_print(char ch) &#123;</span><br><span class="line">    return next(ch) != 0 &amp;&amp; quota &gt; 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void fish_before(char ch) &#123;</span><br><span class="line">  mutex_lock(&amp;lk);</span><br><span class="line">  while (!can_print(ch)) &#123;</span><br><span class="line">    // can proceed only if (next(ch) &amp;&amp; quota)</span><br><span class="line">    cond_wait(&amp;cv, &amp;lk);</span><br><span class="line">  &#125;</span><br><span class="line">  quota--;</span><br><span class="line">  mutex_unlock(&amp;lk);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void fish_after(char ch) &#123;</span><br><span class="line">  mutex_lock(&amp;lk);</span><br><span class="line">  quota++;</span><br><span class="line">  current = next(ch);</span><br><span class="line">  assert(current);</span><br><span class="line">  cond_broadcast(&amp;cv);</span><br><span class="line">  mutex_unlock(&amp;lk);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const char roles[] = &quot;.&lt;&lt;&lt;&lt;&lt;&gt;&gt;&gt;&gt;___&quot;;</span><br><span class="line"></span><br><span class="line">void fish_thread(int id) &#123;</span><br><span class="line">  char role = roles[id];</span><br><span class="line">  while (1) &#123;</span><br><span class="line">    fish_before(role);</span><br><span class="line">    putchar(role);  // Not lock-protected</span><br><span class="line">    fish_after(role);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">  setbuf(stdout, NULL);</span><br><span class="line">  for (int i = 0; i &lt; strlen(roles); i++)</span><br><span class="line">    create(fish_thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://blog.huii.top">HUII</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://blog.huii.top/Note/1c744868e51f.html">https://blog.huii.top/Note/1c744868e51f.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://blog.huii.top" target="_blank">HUII's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a><a class="post-meta__tags" href="/tags/OS/">OS</a></div><div class="post_share"><div class="social-share" data-image="/img/image-8.png" data-sites="qq,wechat,weibo,facebook,twitter"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/Coding/696b8b395e9f.html" title="Python小tips【持续更新】"><img class="cover" src="/img/python.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Python小tips【持续更新】</div></div></a></div><div class="next-post pull-right"><a href="/MachineLearning/4543f3866cda.html" title="YOLO v1笔记"><img class="cover" src="/img/machinelearning.jpeg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">YOLO v1笔记</div></div></a></div></nav><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="gitalk-container"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BB%AA%E8%AE%BA1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0-2023-2-14"><span class="toc-number">1.</span> <span class="toc-text">绪论1_操作系统概述_2023.2.14</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Why%E4%B8%BA%E4%BB%80%E4%B9%88%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F"><span class="toc-number">1.1.</span> <span class="toc-text">Why为什么学操作系统</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#What%E4%BB%80%E4%B9%88%E6%98%AF%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F"><span class="toc-number">1.2.</span> <span class="toc-text">What什么是操作系统</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#How%E6%80%8E%E6%A0%B7%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F"><span class="toc-number">1.3.</span> <span class="toc-text">How怎样学操作系统</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%BE%E7%A8%8B%E4%BB%A3%E7%A0%81"><span class="toc-number">1.4.</span> <span class="toc-text">课程代码</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E6%8B%9F%E6%95%B0%E5%AD%97%E7%B3%BB%E7%BB%9F"><span class="toc-number">1.4.1.</span> <span class="toc-text">模拟数字系统</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E6%8B%9F-RISC-V-%E6%8C%87%E4%BB%A4%E6%89%A7%E8%A1%8C"><span class="toc-number">1.4.2.</span> <span class="toc-text">模拟 RISC-V 指令执行</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BB%AA%E8%AE%BA2-%E5%BA%94%E7%94%A8%E8%A7%86%E8%A7%92%E7%9A%84%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-2023-2-16"><span class="toc-number">2.</span> <span class="toc-text">绪论2_应用视角的操作系统_2023.2.16</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B1%87%E7%BC%96%E4%BB%A3%E7%A0%81%E5%92%8C%E6%9C%80%E5%B0%8F%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6"><span class="toc-number">2.1.</span> <span class="toc-text">汇编代码和最小可执行文件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E6%9C%80%E5%B0%8F%E7%9A%84-Hello-World-%E2%80%9C%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E2%80%9D"><span class="toc-number">2.1.1.</span> <span class="toc-text">构造最小的 Hello, World “应用程序”</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%BA%E8%A1%8C%E6%9E%84%E9%80%A0%E6%9C%80%E5%B0%8F%E7%9A%84-Hello-World%EF%BC%9F"><span class="toc-number">2.1.2.</span> <span class="toc-text">强行构造最小的 Hello, World？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A-Segmentation-Fault%EF%BC%9F"><span class="toc-number">2.1.2.1.</span> <span class="toc-text">为什么会 Segmentation Fault？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E5%BC%82%E5%B8%B8%E9%80%80%E5%87%BA"><span class="toc-number">2.1.3.</span> <span class="toc-text">解决异常退出</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E4%B8%80%E4%BA%9B%E7%BB%86%E8%8A%82%E7%9A%84%E8%A1%A5%E5%85%85%E8%A7%A3%E9%87%8A"><span class="toc-number">2.1.4.</span> <span class="toc-text">对一些细节的补充解释</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B1%87%E7%BC%96%E4%BB%A3%E7%A0%81%E7%9A%84%E7%8A%B6%E6%80%81%E6%9C%BA%E6%A8%A1%E5%9E%8B"><span class="toc-number">2.1.5.</span> <span class="toc-text">汇编代码的状态机模型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%90%86%E8%A7%A3%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F"><span class="toc-number">2.2.</span> <span class="toc-text">理解高级语言程序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%9E%E9%80%92%E5%BD%92%E6%B1%89%E8%AF%BA%E5%A1%94%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.2.0.1.</span> <span class="toc-text">非递归汉诺塔实现</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%90%86%E8%A7%A3%E7%BC%96%E8%AF%91%E5%99%A8"><span class="toc-number">2.3.</span> <span class="toc-text">理解编译器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8A%E7%9A%84%E8%BD%AF%E4%BB%B6-%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F"><span class="toc-number">2.4.</span> <span class="toc-text">操作系统上的软件 (应用程序)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84%E4%BB%BB%E4%BD%95%E7%A8%8B%E5%BA%8F"><span class="toc-number">2.4.1.</span> <span class="toc-text">操作系统中的任何程序</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#define-SECT-SIZE-512"><span class="toc-number">3.</span> <span class="toc-text">define SECT_SIZE  512</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Kill-process-QEMU-on-gdb-exits"><span class="toc-number">4.</span> <span class="toc-text">Kill process (QEMU) on gdb exits</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Connect-to-remote"><span class="toc-number">5.</span> <span class="toc-text">Connect to remote</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#include"><span class="toc-number">6.</span> <span class="toc-text">include </span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#define-ESC-%E2%80%9C-033-%E2%80%9C"><span class="toc-number">7.</span> <span class="toc-text">define ESC “\033[“</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#define-RED-ESC-%E2%80%9C01-31m%E2%80%9D"><span class="toc-number">8.</span> <span class="toc-text">define RED ESC “01;31m”</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#define-CLR-ESC-%E2%80%9C0m%E2%80%9D"><span class="toc-number">9.</span> <span class="toc-text">define CLR ESC “0m”</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#include-1"><span class="toc-number">10.</span> <span class="toc-text">include </span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#include-2"><span class="toc-number">11.</span> <span class="toc-text">include </span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#include-3"><span class="toc-number">12.</span> <span class="toc-text">include </span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#usr-bin-env-python3"><span class="toc-number">13.</span> <span class="toc-text">!&#x2F;usr&#x2F;bin&#x2F;env python3</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#usr-bin-env-python3-1"><span class="toc-number">14.</span> <span class="toc-text">!&#x2F;usr&#x2F;bin&#x2F;env python3</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Mosaic-Emulator-and-Checker"><span class="toc-number">15.</span> <span class="toc-text">Mosaic Emulator and Checker</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-Mosaic-system-calls"><span class="toc-number">15.1.</span> <span class="toc-text">1. Mosaic system calls</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-Process-thread-and-context-switching"><span class="toc-number">15.1.1.</span> <span class="toc-text">1.1 Process, thread, and context switching</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-Virtual-character-device"><span class="toc-number">15.1.2.</span> <span class="toc-text">1.2 Virtual character device</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-Virtual-block-storage-device"><span class="toc-number">15.1.3.</span> <span class="toc-text">1.3 Virtual block storage device</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-System-call-helpers"><span class="toc-number">15.1.4.</span> <span class="toc-text">1.4 System call helpers</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-Mosaic-operating-system-emulator"><span class="toc-number">15.2.</span> <span class="toc-text">2. Mosaic operating system emulator</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-Data-structures"><span class="toc-number">15.2.1.</span> <span class="toc-text">2.1 Data structures</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-The-OperatingSystem-class"><span class="toc-number">15.2.2.</span> <span class="toc-text">2.2 The OperatingSystem class</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-System-call-implementation"><span class="toc-number">15.2.3.</span> <span class="toc-text">2.3 System call implementation</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-1-Process-thread-and-context-switching"><span class="toc-number">15.2.3.1.</span> <span class="toc-text">2.3.1 Process, thread, and context switching</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-2-Virtual-character-device-byte-stream"><span class="toc-number">15.2.4.</span> <span class="toc-text">2.3.2 Virtual character device (byte stream)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-3-Virtual-block-storage-device"><span class="toc-number">15.2.5.</span> <span class="toc-text">2.3.3 Virtual block storage device</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-Operating-system-as-a-state-machine"><span class="toc-number">15.2.6.</span> <span class="toc-text">2.4 Operating system as a state machine</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-Misc-and-helper-functions"><span class="toc-number">15.2.7.</span> <span class="toc-text">2.5 Misc and helper functions</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-The-Mosaic-runtime"><span class="toc-number">15.3.</span> <span class="toc-text">3. The Mosaic runtime</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-Model-interpreter-and-checker"><span class="toc-number">15.3.1.</span> <span class="toc-text">3.1 Model interpreter and checker</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-Source-code-parsing-and-rewriting"><span class="toc-number">15.3.2.</span> <span class="toc-text">3.1 Source code parsing and rewriting</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-Utilities"><span class="toc-number">15.4.</span> <span class="toc-text">4. Utilities</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#include-%E2%80%9Cthread-h%E2%80%9D"><span class="toc-number">16.</span> <span class="toc-text">include “thread.h”</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#include-4"><span class="toc-number">17.</span> <span class="toc-text">include </span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#include-5"><span class="toc-number">18.</span> <span class="toc-text">include </span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#include-6"><span class="toc-number">19.</span> <span class="toc-text">include </span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#include-7"><span class="toc-number">20.</span> <span class="toc-text">include </span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#include-8"><span class="toc-number">21.</span> <span class="toc-text">include </span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#include-9"><span class="toc-number">22.</span> <span class="toc-text">include </span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#include-10"><span class="toc-number">23.</span> <span class="toc-text">include </span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#define-NTHREAD-64"><span class="toc-number">24.</span> <span class="toc-text">define NTHREAD 64</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#include-%E2%80%9Cthread-h%E2%80%9D-1"><span class="toc-number">25.</span> <span class="toc-text">include “thread.h”</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#include-%E2%80%9Cthread-h%E2%80%9D-2"><span class="toc-number">26.</span> <span class="toc-text">include “thread.h”</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#include-11"><span class="toc-number">27.</span> <span class="toc-text">include </span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#include-%E2%80%9Cthread-h%E2%80%9D-3"><span class="toc-number">28.</span> <span class="toc-text">include “thread.h”</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#define-N-100000000"><span class="toc-number">29.</span> <span class="toc-text">define N 100000000</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#define-N-100000000-1"><span class="toc-number">30.</span> <span class="toc-text">define N 100000000</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%94%BE%E5%BC%83-3-%EF%BC%9A%E5%A4%84%E7%90%86%E5%99%A8%E9%97%B4%E7%9A%84%E5%8F%AF%E8%A7%81%E6%80%A7"><span class="toc-number">30.1.</span> <span class="toc-text">放弃 (3)：处理器间的可见性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%8E%B0%E4%BB%A3%E5%A4%84%E7%90%86%E5%99%A8%E4%B9%9F%E6%98%AF-%E5%8A%A8%E6%80%81-%E7%BC%96%E8%AF%91%E5%99%A8%EF%BC%81"><span class="toc-number">30.1.1.</span> <span class="toc-text">现代处理器也是 (动态) 编译器！</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%BD%E6%9D%BE%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B-Relaxed-Weak-Memory-Model"><span class="toc-number">30.1.2.</span> <span class="toc-text">宽松内存模型 (Relaxed&#x2F;Weak Memory Model)</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B9%B6%E5%8F%912-%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6%E5%9F%BA%E7%A1%80-2023-3-9"><span class="toc-number">31.</span> <span class="toc-text">并发2_并发控制基础_2023.3.9</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%92%E6%96%A5%E9%97%AE%E9%A2%98"><span class="toc-number">31.1.</span> <span class="toc-text">互斥问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%9A%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83"><span class="toc-number">31.1.1.</span> <span class="toc-text">并发编程：从入门到放弃</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9E%E9%80%80%E5%88%B0%E9%A1%BA%E5%BA%8F%E6%89%A7%E8%A1%8C%EF%BC%9A%E4%BA%92%E6%96%A5"><span class="toc-number">31.1.2.</span> <span class="toc-text">回退到顺序执行：互斥</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%B1%E8%B4%A5%E7%9A%84%E5%B0%9D%E8%AF%95"><span class="toc-number">31.1.3.</span> <span class="toc-text">失败的尝试</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9B%B4%E4%B8%A5%E8%82%83%E5%9C%B0%E5%B0%9D%E8%AF%95%EF%BC%9A%E7%A1%AE%E5%AE%9A%E5%81%87%E8%AE%BE%E3%80%81%E8%AE%BE%E8%AE%A1%E7%AE%97%E6%B3%95"><span class="toc-number">31.1.4.</span> <span class="toc-text">更严肃地尝试：确定假设、设计算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%A3%E7%A1%AE%E6%80%A7%E4%B8%8D%E6%98%8E%E7%9A%84%E5%A5%87%E6%80%AA%E5%B0%9D%E8%AF%95-Peterson-%E7%AE%97%E6%B3%95"><span class="toc-number">31.1.5.</span> <span class="toc-text">正确性不明的奇怪尝试 (Peterson 算法)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B9%A0%E9%A2%98%EF%BC%9A%E8%AF%81%E6%98%8E-Peterson-%E7%AE%97%E6%B3%95%E6%AD%A3%E7%A1%AE%EF%BC%8C%E6%88%96%E7%BB%99%E5%87%BA%E5%8F%8D%E4%BE%8B"><span class="toc-number">31.1.6.</span> <span class="toc-text">习题：证明 Peterson 算法正确，或给出反例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%95%E6%9D%A5%E7%BB%95%E5%8E%BB%E5%BE%88%E5%AE%B9%E6%98%93%E6%9C%89%E9%94%99%E6%BC%8F%E7%9A%84%E6%83%85%E5%86%B5"><span class="toc-number">31.1.7.</span> <span class="toc-text">绕来绕去很容易有错漏的情况</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E5%9E%8B%E3%80%81%E6%A8%A1%E5%9E%8B%E6%A3%80%E9%AA%8C%E4%B8%8E%E7%8E%B0%E5%AE%9E"><span class="toc-number">31.2.</span> <span class="toc-text">模型、模型检验与现实</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%80%9CPush-button%E2%80%9D-Verification-%F0%9F%8E%96"><span class="toc-number">31.2.1.</span> <span class="toc-text">“Push-button” Verification 🎖</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E9%81%8D%E5%8E%86%E7%8A%B6%E6%80%81%E7%A9%BA%E9%97%B4%E7%9A%84%E4%B9%90%E8%B6%A3"><span class="toc-number">31.2.2.</span> <span class="toc-text">自动遍历状态空间的乐趣</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8E%E6%A8%A1%E5%9E%8B%E5%9B%9E%E5%88%B0%E7%8E%B0%E5%AE%9E%E2%80%A6%E2%80%A6"><span class="toc-number">31.2.3.</span> <span class="toc-text">从模型回到现实……</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E5%AD%90%E6%8C%87%E4%BB%A4"><span class="toc-number">31.3.</span> <span class="toc-text">原子指令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9B%B0%E9%9A%BE%E7%9A%84%E8%A7%A3%E5%86%B3"><span class="toc-number">31.3.1.</span> <span class="toc-text">并发编程困难的解决</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E6%AD%A3%E7%A1%AE%E7%9A%84%E6%B1%82%E5%92%8C"><span class="toc-number">31.3.2.</span> <span class="toc-text">实现正确的求和</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E8%AF%91%E5%99%A8%E5%92%8C%E7%A1%AC%E4%BB%B6%E7%9A%84%E5%8D%8F%E4%BD%9C"><span class="toc-number">31.3.3.</span> <span class="toc-text">编译器和硬件的协作</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B9%B6%E5%8F%913-%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6%EF%BC%9A%E4%BA%92%E6%96%A5-2023-3-14"><span class="toc-number">32.</span> <span class="toc-text">并发3_并发控制：互斥_2023.3.14</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%92%E6%96%A5%E9%97%AE%E9%A2%98%EF%BC%9A%E5%AE%9A%E4%B9%89%E4%B8%8E%E5%81%87%E8%AE%BE"><span class="toc-number">32.1.</span> <span class="toc-text">互斥问题：定义与假设</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%92%E6%96%A5%E9%97%AE%E9%A2%98%EF%BC%9A%E5%AE%9A%E4%B9%89"><span class="toc-number">32.1.1.</span> <span class="toc-text">互斥问题：定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%92%E6%96%A5%E9%97%AE%E9%A2%98%E7%9A%84%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95"><span class="toc-number">32.1.2.</span> <span class="toc-text">互斥问题的经典算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E4%BA%92%E6%96%A5%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%81%87%E8%AE%BE"><span class="toc-number">32.1.3.</span> <span class="toc-text">实现互斥的基本假设</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Atomic-Exchange-%E5%AE%9E%E7%8E%B0"><span class="toc-number">32.1.4.</span> <span class="toc-text">Atomic Exchange 实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E6%97%8B%E9%94%81-Spin-Lock"><span class="toc-number">32.2.</span> <span class="toc-text">自旋锁 (Spin Lock)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E6%97%8B%E9%94%81-Spin-Lock-1"><span class="toc-number">32.2.1.</span> <span class="toc-text">自旋锁 (Spin Lock)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E6%97%8B%E9%94%81%EF%BC%9A%E7%94%A8-xchg-%E5%AE%9E%E7%8E%B0%E4%BA%92%E6%96%A5"><span class="toc-number">32.2.2.</span> <span class="toc-text">自旋锁：用 xchg 实现互斥</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E4%BA%92%E6%96%A5%EF%BC%9A%E8%87%AA%E6%97%8B%E9%94%81"><span class="toc-number">32.2.3.</span> <span class="toc-text">实现互斥：自旋锁</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9B%B4%E5%BC%BA%E5%A4%A7%E7%9A%84%E5%8E%9F%E5%AD%90%E6%8C%87%E4%BB%A4"><span class="toc-number">32.3.</span> <span class="toc-text">更强大的原子指令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9B%B4%E5%BC%BA%E5%A4%A7%E7%9A%84%E5%8E%9F%E5%AD%90%E6%8C%87%E4%BB%A4-1"><span class="toc-number">32.3.1.</span> <span class="toc-text">更强大的原子指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8%E8%87%AA%E6%97%8B%E9%94%81%E4%B8%AD%E4%BB%A3%E6%9B%BF-xchg"><span class="toc-number">32.3.2.</span> <span class="toc-text">在自旋锁中代替 xchg</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E5%87%BA%E7%9A%84-Compare-%E7%94%A8%E5%A4%84"><span class="toc-number">32.3.3.</span> <span class="toc-text">多出的 Compare: 用处</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9C%A8%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8A%E5%AE%9E%E7%8E%B0%E4%BA%92%E6%96%A5"><span class="toc-number">32.4.</span> <span class="toc-text">在操作系统上实现互斥</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E6%97%8B%E9%94%81%E7%9A%84%E7%BC%BA%E9%99%B7"><span class="toc-number">32.4.1.</span> <span class="toc-text">自旋锁的缺陷</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Scalability-%E6%80%A7%E8%83%BD%E7%9A%84%E6%96%B0%E7%BB%B4%E5%BA%A6"><span class="toc-number">32.4.2.</span> <span class="toc-text">Scalability: 性能的新维度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E6%97%8B%E9%94%81%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">32.4.3.</span> <span class="toc-text">自旋锁的使用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B-%E9%95%BF%E4%B8%B4%E7%95%8C%E5%8C%BA%E7%9A%84%E4%BA%92%E6%96%A5"><span class="toc-number">32.4.4.</span> <span class="toc-text">实现线程 + 长临界区的互斥</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B9%B6%E5%8F%914-%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6%EF%BC%9A%E8%B0%83%E8%AF%95%E7%90%86%E8%AE%BA%E4%B8%8E%E5%AE%9E%E8%B7%B5-2023-3-16"><span class="toc-number">33.</span> <span class="toc-text">并发4_并发控制：调试理论与实践_2023.3.16</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B0%83%E8%AF%95%E7%90%86%E8%AE%BA"><span class="toc-number">33.1.</span> <span class="toc-text">调试理论</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-GDB-%E8%B0%83%E8%AF%95%E7%A8%8B%E5%BA%8F"><span class="toc-number">33.2.</span> <span class="toc-text">使用 GDB 调试程序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#GDB-%E5%85%A5%E9%97%A8"><span class="toc-number">33.3.</span> <span class="toc-text">GDB: 入门</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%8C%B6%EF%B8%8F-Futex-Fast-Userspace-muTexes-cont%E2%80%99d"><span class="toc-number">33.4.</span> <span class="toc-text">🌶️ Futex: Fast Userspace muTexes (cont’d)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B0%83%E8%AF%95%E7%90%86%E8%AE%BA%EF%BC%9A%E5%BA%94%E7%94%A8"><span class="toc-number">33.5.</span> <span class="toc-text">调试理论：应用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B0%83%E8%AF%95%E7%90%86%E8%AE%BA%EF%BC%9A%E5%BA%94%E7%94%A8-Again"><span class="toc-number">33.6.</span> <span class="toc-text">调试理论：应用 (Again)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%96%E7%A8%8B%E5%9F%BA%E6%9C%AC%E5%87%86%E5%88%99%EF%BC%9A%E5%9B%9E%E9%A1%BE"><span class="toc-number">33.7.</span> <span class="toc-text">编程基本准则：回顾</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B0%83%E8%AF%95%E7%90%86%E8%AE%BA%E7%9A%84%E6%9C%80%E9%87%8D%E8%A6%81%E5%BA%94%E7%94%A8"><span class="toc-number">33.8.</span> <span class="toc-text">调试理论的最重要应用</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B9%B6%E5%8F%915-%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6%EF%BC%9A%E5%90%8C%E6%AD%A5-1-2023-3-21"><span class="toc-number">34.</span> <span class="toc-text">并发5_并发控制：同步 (1)_2023.3.21</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E9%97%AE%E9%A2%98"><span class="toc-number">34.1.</span> <span class="toc-text">同步问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5-Synchronization"><span class="toc-number">34.2.</span> <span class="toc-text">同步 (Synchronization)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%9F%E4%BA%A7%E8%80%85-%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98%EF%BC%9A%E5%AD%A6%E5%BA%9F%E4%BD%A0%E5%B0%B1%E8%B5%A2%E4%BA%86"><span class="toc-number">34.3.</span> <span class="toc-text">生产者-消费者问题：学废你就赢了</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E5%9B%BE%E3%80%81%E8%B0%83%E5%BA%A6%E5%99%A8%E5%92%8C%E7%94%9F%E4%BA%A7%E8%80%85-%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98"><span class="toc-number">34.4.</span> <span class="toc-text">计算图、调度器和生产者-消费者问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%9F%E4%BA%A7%E8%80%85-%E6%B6%88%E8%B4%B9%E8%80%85%EF%BC%9A%E5%AE%9E%E7%8E%B0"><span class="toc-number">34.5.</span> <span class="toc-text">生产者-消费者：实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F"><span class="toc-number">34.6.</span> <span class="toc-text">条件变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E9%97%AE%E9%A2%98%EF%BC%9A%E5%88%86%E6%9E%90"><span class="toc-number">34.7.</span> <span class="toc-text">同步问题：分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F%EF%BC%9A%E7%90%86%E6%83%B3%E4%B8%8E%E5%AE%9E%E7%8E%B0%E4%B9%8B%E9%97%B4%E7%9A%84%E6%8A%98%E8%A1%B7"><span class="toc-number">34.8.</span> <span class="toc-text">条件变量：理想与实现之间的折衷</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F%EF%BC%9A%E5%BA%94%E7%94%A8"><span class="toc-number">34.9.</span> <span class="toc-text">条件变量：应用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F%EF%BC%9A%E4%B8%87%E8%83%BD%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97%E6%A1%86%E6%9E%B6-M2"><span class="toc-number">34.10.</span> <span class="toc-text">条件变量：万能并行计算框架 (M2)</span></a></li></ol></li></ol></div></div></div></div></main><footer id="footer" style="background-image: url('/img/image-8.png')"><div id="footer-wrap"><div class="copyright">&copy;2015 - 2025 By HUII</div><div class="footer_custom_text"><span>备案号：<a href="https://beian.miit.gov.cn/" target="_blank">闽ICP备18005042号-2</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, '']
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typesetPromise()
}</script><script>function loadGitalk () {
  function initGitalk () {
    var gitalk = new Gitalk(Object.assign({
      clientID: 'ce436d2d4a3e549dad64',
      clientSecret: '9a40a66c694e77b58120d1b62b2dcee193963143',
      repo: 'huiiz.github.io',
      owner: 'huiiz',
      admin: ['huiiz'],
      id: '84764dc88b6ebb2feeddfa3f837119e3',
      updateCountCallback: commentCount
    },null))

    gitalk.render('gitalk-container')
  }

  if (typeof Gitalk === 'function') initGitalk()
  else {
    getCSS('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css')
    getScript('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.js').then(initGitalk)
  }
}

function commentCount(n){
  let isCommentCount = document.querySelector('#post-meta .gitalk-comment-count')
  if (isCommentCount) {
    isCommentCount.textContent= n
  }
}

if ('Gitalk' === 'Gitalk' || !false) {
  if (false) btf.loadComment(document.getElementById('gitalk-container'), loadGitalk)
  else loadGitalk()
} else {
  function loadOtherComment () {
    loadGitalk()
  }
}</script></div><div style="display:none;"><script type="text/javascript" src="https://v1.cnzz.com/z_stat.php?id=1279897347&web_id=1279897347"></script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>